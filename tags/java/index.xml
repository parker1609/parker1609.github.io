<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Java on Parker Blog</title>
    <link>https://parker1609.github.io/tags/java/</link>
    <description>Recent content in Java on Parker Blog</description>
    <image>
      <title>Parker Blog</title>
      <url>https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 26 Feb 2023 14:45:58 +0900</lastBuildDate><atom:link href="https://parker1609.github.io/tags/java/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>자바 웹 기술 역사</title>
      <link>https://parker1609.github.io/post/java-web-history/</link>
      <pubDate>Sun, 26 Feb 2023 14:45:58 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/java-web-history/</guid>
      <description>1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다.</description>
    </item>
    
    <item>
      <title>Java 11 vs Java 17</title>
      <link>https://parker1609.github.io/post/java-11-vs-java-17/</link>
      <pubDate>Fri, 24 Feb 2023 11:53:53 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/java-11-vs-java-17/</guid>
      <description>1. 지원기간 https://www.oracle.com/java/technologies/java-se-support-roadmap.html
자바 11버전은 최대 2026년 9월까지 지원 자바 17버전은 최대 2029년 9월까지 지원 2. Java 11 VS 17, 주요 변경사항 아래 예제 코드의 전체는 https://github.com/programming-starter/java-17-starter 이 링크에서 확인할 수 있습니다.
Text Blocks 문자열을 좀 더 읽기 좋게 표현할 수 있게 되었다. 특히 JSON과 같은 문자열을 표현할 때, 예전에는 다음과 같이 표현해야 했다.
{ &amp;#34;name&amp;#34;: &amp;#34;parker&amp;#34;, &amp;#34;age&amp;#34;: 30, &amp;#34;job&amp;#34;: &amp;#34;Programmer&amp;#34; } @Test void old_style() { var json = &amp;#34;{\n&amp;#34; + &amp;#34; \&amp;#34;name\&amp;#34;: \&amp;#34;parker\&amp;#34;,\n&amp;#34; + &amp;#34; \&amp;#34;age\&amp;#34;: 30,\n&amp;#34; + &amp;#34; \&amp;#34;job\&amp;#34;: \&amp;#34;Programmer\&amp;#34;\n&amp;#34; + &amp;#34;}&amp;#34;; System.</description>
    </item>
    
    <item>
      <title>동적 프록시(Dynamic Proxy) with Spring Framework</title>
      <link>https://parker1609.github.io/post/dynamic-proxy-with-spring/</link>
      <pubDate>Sun, 04 Sep 2022 09:17:32 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/dynamic-proxy-with-spring/</guid>
      <description>디자인 패턴 글 중 프록시 패턴과 데코레이터 패턴에서 프록시를 코드로 구현하는 방법을 알아보았다. (이전 글 참고) 그런데 프록시를 적용해야 할 클래스가 수십 개에서 수백 개가 되면 어떻게 될까? 이러한 프록시 클래스를 그 개수만큼 반복해서 만들어주어야 한다.
이러한 불편함을 해소하기 위해 나온 기술이 동적 프록시(Dynamic Proxy)이다. 동적 프록시는 말그대로 동적인 시점(런타임 시점)에 프록시를 자동으로 만들어서 적용해주는 기술이다.
자바에서 대표적인 동적 프록시 기술은 JDK 동적 프록시와 CGLIB(Code Generator LIBrary)이 있다. 두 기술 모두 동적 프록시를 만들어주지만, 차이점은 다음과 같다.</description>
    </item>
    
    <item>
      <title>[디자인 패턴] 프록시 패턴/데코레이터 패턴</title>
      <link>https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/</link>
      <pubDate>Thu, 25 Aug 2022 09:12:33 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/</guid>
      <description>이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&amp;rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.
프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.
접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다.</description>
    </item>
    
    <item>
      <title>[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴</title>
      <link>https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/</link>
      <pubDate>Fri, 19 Aug 2022 10:47:30 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/</guid>
      <description>이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.
패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.
전체 예제 코드는 이 링크에서 볼 수 있습니다.
예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다.</description>
    </item>
    
  </channel>
</rss>
