<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>서버 이중화(Redundancy) | Parker Blog</title><meta name=keywords content="Server,Redundancy,High Availability"><meta name=description content="이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.
그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.
이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/server-redundancy/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="서버 이중화(Redundancy)"><meta property="og:description" content="이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.
그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.
이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/server-redundancy/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-06-02T17:38:57+09:00"><meta property="article:modified_time" content="2024-06-02T17:38:57+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="서버 이중화(Redundancy)"><meta name=twitter:description content="이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.
그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.
이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"서버 이중화(Redundancy)","item":"https://parker1609.github.io/post/server-redundancy/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"서버 이중화(Redundancy)","name":"서버 이중화(Redundancy)","description":"이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.\n그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.\n이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다.","keywords":["Server","Redundancy","High Availability"],"articleBody":"이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.\n그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.\n이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다. 반면에 이를 구성하기 위해 비용이 크고 시스템이 복잡해진다는 단점이 있습니다.\n용어 알아보기 고가용성(High Availability) 시스템이나 서비스가 가능한 한 오랫동안 중단 없이 운영될 수 있는 능력.\n결함 감내(Fault Tolerance) 시스템이 일부 구성 요소의 장애에도 불구하고 정상적으로 동작할 수 있는 능력.\n이중화 사례 한국에서는 너무도 유명해진 ‘카카오 데이터 센터 화재’ 사건이 있습니다. 2022년 10월 15일 15시 19분에 카카오가 사용중인 SK C\u0026C 판교 데이터센터에 화재가 발생합니다. 이로 인해서 카카오톡을 포함한 카카오 전반적인 서비스에 장애가 발생하여 서비스가 중단되었습니다. 모든 서비스가 정상적으로 복구되기까지는 5일이 지난 10월 20일이었습니다.\n카카오 서비스는 물론 이중화를 갖춘 시스템이었지만 완벽하지 않았습니다. 일부 이중화된 구성 요소와 장애 대응을 위한 도구가 판교 데이터 센터에만 있었고, 장애 모니터링과 자동화 프로세스가 미흡하였습니다. 결국 일부 서비스에 한해서는 판교 데이터 센터 자체가 SPoF인 상황에 놓이게 되었고, 여기서 장애가 발생하자 일부 서비스로 인해 전체 서비스가 중단되는 문제가 발생하였다고 볼 수 있습니다.\n(카카오 서비스 장애 사건에 대해서는 https://www.kakaocorp.com/page/detail/9902 여기서 자세히 살펴볼 수 있습니다.)\n이처럼 이중화는 서버를 2개 이상으로 구성만 했다고 해서 서비스를 안정적으로 유지할 수는 없습니다. SPoF가 되는 부분을 모두 이중화를 해야하고, 데이터 센터조차도 이중화가 필요합니다. 그리고 이를 관리하기 위한 모니터링 구축도 필요합니다. 이중화는 비용이 매우 큰 작업이기 때문에 어쩔 수 없이 적절한 타협 지점을 찾아야할 지도 모릅니다.\n서버 이중화 구조 일반적으로 서버를 이중화하는 구조는 크게 2가지로 나뉩니다.\nActive-Standby Active-Active 여기서 Active는 활성화가 되어있는 상태를 말합니다. 서버가 정상적으로 동작하고 있는 것입니다.\n반면, Standby는 대기 상태로 말그대로 리소스는 차지하고 있지만 동작을 하고 있는 않은 상태입니다.\n위는 우리가 웹 요청을 받는 서버 구조를 매우 간단히 표현한 그림입니다.\n만약 위로만 서버를 구성한다면, 장애가 발생하면 서비스는 중단됩니다. 바로 SPOF 문제죠.\nSPOF 문제를 해결하기 위해서 서버를 이중화해봅시다.\nActive-Standby(Passive) 같은 서버군을 물리적으로 분리하여 2개의 서버로 구성하였습니다. Active-Standby는 하나의 서버는 활성화 상태로 사용하고, 하나는 장애 대비를 위해서 대기하는 서버입니다.\n위 그림처럼 요청은 Active된 서버에서만 처리를 합니다. 만약 장애가 발생하면 대기하는 서버가 있기 때문에 빠르게 전환하여 서비스의 중단 시간을 최소화할 수 있습니다. 하지만 결국 전환 시간이 필요하기 때문에 서비스가 중단되는 시간이 필요합니다.\n정리하면, Active-Standby 구조의 장단점은 다음과 같습니다.\n장점 구조나 설정이 비교적 간단 단점 대기 서버는 비활성 상태에서 리소스가 계속 낭비 장애 발생 시 전환 시간이 필요 용어 알아보기 Failover (페일오버) 페일오버는 이중화된 시스템에서 하나의 구성 요소가 실패할 경우, 자동으로 대체 구성 요소로 전환하는 프로세스를 말합니다.\nActive-Standby 이중화 구조에서 페일오버라고 하면, Active 서버가 장애가 발생하여 Standby 서버가 대기 상태에서 활성화 상태로 변하면서 전환하는 과정을 의미합니다.\nFailback (페일백) 페일백은 시스템이 장애로 인해 대체 시스템(또는 보조 시스템)으로 전환된 후, 원래의 주 시스템이 복구되었을 때 다시 원래 시스템으로 돌아가는 프로세스를 말합니다.\nActive-Standby 이중화 구조에서 Active 서버가 장애가 발생하여 Standby 서버가 이를 대체한 후에 장애가 복구되어 다시 Active 였던 주 서버로 되돌아가는 과정을 말합니다.\nSwitchover (스위치오버) 페일오버가 장애가 발생하였을 때 자동으로 두 시스템 간의 전환이 이루어졌다면, 스위치오버는 자동이 아니라 수동으로 이 과정이 이루어지는 것을 말합니다. 이는 주로 계획된 유지보수나 업그레이드 또는 테스트 상황에서 사용됩니다.\nActive-Active 앞서 살펴본 Active-Standby 구조에서 결국 장애 발생시 서비스가 중단이 된다는 치명적인 단점이 있었고, 리소스 역시 낭비되고 있었습니다.\n이를 해결하기 위해 Active-Active 구조를 활용할 수 있습니다.\nActive-Active 구조는 2개의 서버가 모두 활성화되어 사용할 수 있는 구조입니다. 따라서 사용자 요청을 2개 서버에서 모두 처리할 수 있어 리소스가 낭비되지 않고 요청 처리량도 늘어납니다.\n중요한 점은 만약 2개의 서버 중 하나가 장애가 발생하더라도 나머지 하나가 계속 활성화 상태로 처리할 수 있기 때문에 장애로 인한 서비스 중단이 발생하지 않습니다.\n그럼 여기서 한 가지 궁금증이 생길 수 있습니다. ‘물리적인 서버가 두 개가 되면 요청이 어디로 갈지 어떻게 중재해줄 수 있을까?’ 단순히 서버가 2개가 생긴다고 해서 SPOF를 해결했다고 볼 수는 없습니다. 요청이 들어왔을 때, 두 서버중에 어디로 가야할지 알아야 합니다.\n서버는 물리적으로 분리가 되어있는 상태입니다. 즉, 각각의 서버의 MAC 주소가 분리되어 있는 상황이죠. 간단히 말하면 컴퓨터가 2대가 있는데 여기에 각각 서버가 구성되어 있는 환경입니다. 만약 요청이 들어왔을 때 이 컴퓨터 2대 중에 어디로 가야할지 결정을 해야합니다.\n이 때 LACP(Link Aggregation Control Protocol)를 구성합니다. LACP는 물리적인 네트워크 인터페이스를 묶어서 단일 논리적 링크를 구성하는 기술입니다. 이는 IEEE 802.3ad 표준으로 정의되어 있으며, 네트워크 스위치와 장비 간에 링크를 동적으로 결합하고 관리하는 프로토콜입니다.\nLACP를 활용하여 2개의 물리 서버를 하나의 논리적인 장비로 묶어서 여기서 요청을 받아 어느 물리 서버로 보내야 할지 결정을 합니다. 일종의 로드밸런서와 같은 역할을 한다고 생각하면 이해하기 편할 것 같습니다.\n지금까지는 하드웨어 관점에서 살펴보았습니다. 소프트웨어 관점에서도 이중화가 필요합니다. 서버 개발자 입장에서는 이 부분을 직접 설정하고 활용해야할 때가 대부분일 것입니다. 특히, 클라우드와 쿠버네티스 환경이 대부분 자리잡은 상황에서 소프트웨어 이중화는 더욱 쉽고 편리하게 구성이 가능하게 되었습니다.\n장점 장애가 발생하더라도 중단없이 서비스 제공 가능 리소스를 효율적으로 사용 가능 (처리량 증가) 단점 추가적인 구성이 필요하고 설정이 복잡해짐. 장애감지 모니터링 이중화에서 중요한 요소 중 하나는 장애가 발생했을 때, 이를 감지하는 것입니다. 장애를 빨리 감지할수록 복구하는 비용이나 사용자의 불편함 등이 최소화되는 것은 당연합니다.\n장애가 발생할 수 있는 지점은 크게 3가지 입니다.\n네트워크 장애 서버 물리 장비 장애 소프트웨어 (OS, 서버 애플리케이션 등) 장애 이와 같이 지점에서 발생하는 장애를 감지하기 위해서는 크게 두 가지를 할 수 있습니다.\nHeartbeat 신호를 주기적으로 보내 정상 응답을 하는지 검사하기 시스템 로그에서 실시간으로 오류 메시지나 비정상적인 패턴이 발생하는지 검사하기 위 두 가지를 검사하는 Agent를 장애가 발생할 수 있는 지점인 3 곳에 설치하여 이상이 있을 시에 알림을 받을 수 있도록 해야합니다.\n이처럼 문제가 발생했을 때 알아차리는 것도 중요하지만, 문제가 발생할 수 있음을 짐작해서 미리 대비하는 것도 중요합니다. 이를 위해서는 CPU 및 메모리 사용량, 네트워크 트래픽, 디스크 I/O 및 애플리케이션 응답 시간 등 다양한 지표를 시각화하여 모니터링을 할 수 있어야 하고, 특정 임계치가 넘어갔을 때 알림을 준다거나 자동으로 자원을 정리하거나 서버를 재시작하는 등의 대응을 자동화해볼 수도 있습니다.\n데이터 복제 이중화에서 2개 서버가 동일한 데이터에 항상 접근할 수 있어야 하는 데이터 무결성을 보장해야합니다. 위에서 이중화 구조 그림에서도 살펴보았지만, 데이터를 저장하고 있는 DB도 결국 서버이므로 이중화를 통해 고가용성을 보장해야합니다. 이로인해서 같은 데이터가 여러 곳에 있을 수 있기 때문에 데이터의 일관성을 보장하는 것이 중요합니다.\n데이터 복제는 복제 중인 데이터가 시간이 지나면서 변경이 발생하기 때문에 이에 대한 데이터 일관성을 보장하기에는 많은 노력이 요구되고 트레이드오프가 발생합니다.\nDR (Disaster Recover, 재해 복구) 이중화에서 더 나아가서 더 안전한 서버 환경을 구성하기 위해서는 DR을 구성할 수 있습니다. DR은 자연재해나 인간의 행동(또는 실수)로 인한 재해가 발생한 후 IT 인프라에 대한 접근 및 기능을 복원할 수 있는 기능을 말합니다.\n재해로 인해서 피해가 가장 크게 발생할 수 있는 곳이 물리 서버가 동작하고 있는 데이터 센터입니다. 만약 자연재해나 인재로 인해 데이터 센터 자체가 장애 상황이 발생한다면 이 데이터 센터 내에서 2개의 물리 장비를 사용하여 이중화를 하였다고 해도 무용지물입니다. 그래서 데이터 센터 자체를 이중화하여 DR을 수행할 수 있습니다.\nDR을 위한 데이터 센터를 ‘DR 센터’라고도 부릅니다. DR 센터는 백업을 위한 센터라고도 볼 수 있지만 사실 단순히 데이터 센터를 하나 더 사용하는 형태로도 볼 수 있습니다. 단, DR을 수행하기 위해서 두 데이터 센터는 물리적으로 떨어진 지역에 위치하고 있어야 합니다. 두 데이터 센터가 너무 가까이 있다면 재해 역시 같이 영향을 받을 확률이 크기 때문에 적당한 거리를 유지하는 것이 중요합니다. (그렇다고 거리가 너무 멀게 되면 두 데이터 센터간 통신 속도나 실제 이동거리 등 효율이 매우 떨어질 수도 있습니다.)\n위는 이중화된 서버를 각각 두 개의 데이터 센터에 할당이 되어 있는 모습입니다. DR을 만족하는 이중화라면 위처럼 물리 서버 장비 역시 각각의 데이터 센터에 존재하게 해야합니다. 만약 A 데이터센터에서 화재가 발생하여 먹통이 되더라도 B 데이터센터가 살아있기 때문에 서비스는 빠르게 장애를 극복할 수 있을 것입니다.\n이러한 재해 복구 시스템은 복구 시간 및 시점에 따라 크게 4가지 유형으로 구분됩니다.\n먼저, 유형을 살펴보기 전에 2개 용어를 살펴보겠습니다.\nRTO (Recovery Time Objective, 복구 시간 목표): 재해 발생 시 시스템이나 서비스가 복구되기까지 최대 시간. 예를 들어, RTO가 4시간이면, 재해 발생 시 4시간 이내에 복구가 완료되는 것을 목표로 합니다. 따라서 그 시간 동안에는 서비스가 중단이 될 수 있습니다.\nRPO (Recovery Point Objective, 복구): 재해 발생 시 데이터 손실이 발생하는 최대 시간. 즉, 마지막 백업 시점과 재해 발생 시점 간의 데이터 손실 범위. 예를들어, RPO가 4시간이면, 4시간 마다 백업을 합니다. 따라서 마지막 백업 이후 3시간 만에 재해가 발생했다면 이 3시간 동안의 데이터는 손실됩니다.\nRTO와 RPO에 따라 미러 사이트, 핫 사이트, 웜 사이트, 콜드 사이트 이렇게 4 가지 유형이 존재합니다. (이 단계의 상세사항은 2007년 한국정보통신기술에서 제공한 정보시스템 재해 복구 지침을 참고하였습니다.)\n[1등급] 미러 사이트 (Mirror Site) 동일한 수준의 데이터 센터를 DR 센터로 두고, 두 데이터 센터를 Active-Active 구조로 구축합니다. 이 두 데이터 센터는 실시간 동기화가 이루어집니다. RTO: 0 (이론상) RPO: 0 (이론상) 장점: 장애가 발생하더라도 서비스 중단과 데이터 손실이 없습니다. (데이터 최신성, 높은 안정성) 단점: 초기 투자 및 유지보수 비용이 큽니다. [2등급] 핫 사이트 (Hot Site) 동일한 수준의 데이터 센터를 DR 센터로 두고, 두 데이터 센터를 Active-Standby 구조로 구축합니다. Active 중인 데이터 센터가 재해 발생 시 Standby에 있던 또 다른 데이터 센터를 Active로 전환하여 failover를 수행합니다. RTO: 0 RPO: 수 시간 (보통 4시간) [3등급] 웜 사이트 (Warm Site) 중요한 데이터만 부분적으로 DR 센터에 둡니다. RTO: 수 일 ~ 수 주 RPO: 수 시간 ~ 1일 [4등급] 콜드 사이트 (Cold Site) 서비스에 필요한 최소한의 데이터만 DR 센터에 둡니다. RTO: 수 주 ~ 수 개월 RPO: 수 일 ~ 수 주 ","wordCount":"1479","inLanguage":"en","datePublished":"2024-06-02T17:38:57+09:00","dateModified":"2024-06-02T17:38:57+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/server-redundancy/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/ title=Home><span>Home</span></a></li><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>서버 이중화(Redundancy)</h1><div class=post-meta><span title='2024-06-02 17:38:57 +0900 KST'>June 2, 2024</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%9d%b4%ec%a4%91%ed%99%94-redundancy aria-label="이중화 (Redundancy)">이중화 (Redundancy)</a><ul><ul><li><a href=#%ec%9a%a9%ec%96%b4-%ec%95%8c%ec%95%84%eb%b3%b4%ea%b8%b0 aria-label="용어 알아보기">용어 알아보기</a><ul><li><a href=#%ea%b3%a0%ea%b0%80%ec%9a%a9%ec%84%b1high-availability aria-label="고가용성(High Availability)">고가용성(High Availability)</a></li><li><a href=#%ea%b2%b0%ed%95%a8-%ea%b0%90%eb%82%b4fault-tolerance aria-label="결함 감내(Fault Tolerance)">결함 감내(Fault Tolerance)</a></li></ul></li></ul></ul></li><li><a href=#%ec%9d%b4%ec%a4%91%ed%99%94-%ec%82%ac%eb%a1%80 aria-label="이중화 사례">이중화 사례</a></li><li><a href=#%ec%84%9c%eb%b2%84-%ec%9d%b4%ec%a4%91%ed%99%94-%ea%b5%ac%ec%a1%b0 aria-label="서버 이중화 구조">서버 이중화 구조</a><ul><li><a href=#active-standbypassive aria-label=Active-Standby(Passive)>Active-Standby(Passive)</a><ul><li><a href=#%ec%9a%a9%ec%96%b4-%ec%95%8c%ec%95%84%eb%b3%b4%ea%b8%b0-1 aria-label="용어 알아보기">용어 알아보기</a><ul><li><a href=#failover-%ed%8e%98%ec%9d%bc%ec%98%a4%eb%b2%84 aria-label="Failover (페일오버)">Failover (페일오버)</a></li><li><a href=#failback-%ed%8e%98%ec%9d%bc%eb%b0%b1 aria-label="Failback (페일백)">Failback (페일백)</a></li><li><a href=#switchover-%ec%8a%a4%ec%9c%84%ec%b9%98%ec%98%a4%eb%b2%84 aria-label="Switchover (스위치오버)">Switchover (스위치오버)</a></li></ul></li></ul></li><li><a href=#active-active aria-label=Active-Active>Active-Active</a></li></ul></li><li><a href=#%ec%9e%a5%ec%95%a0%ea%b0%90%ec%a7%80-%eb%aa%a8%eb%8b%88%ed%84%b0%eb%a7%81 aria-label="장애감지 모니터링">장애감지 모니터링</a></li><li><a href=#%eb%8d%b0%ec%9d%b4%ed%84%b0-%eb%b3%b5%ec%a0%9c aria-label="데이터 복제">데이터 복제</a></li><li><a href=#dr-disaster-recover-%ec%9e%ac%ed%95%b4-%eb%b3%b5%ea%b5%ac aria-label="DR (Disaster Recover, 재해 복구)">DR (Disaster Recover, 재해 복구)</a></li></ul></div></details></div><div class=post-content><h1 id=이중화-redundancy>이중화 (Redundancy)<a hidden class=anchor aria-hidden=true href=#이중화-redundancy>#</a></h1><p>이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도
다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.</p><p>그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에
해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가
실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다.
이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.</p><p>이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를
보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다.
반면에 이를 구성하기 위해 비용이 크고 시스템이 복잡해진다는 단점이 있습니다.</p><h3 id=용어-알아보기>용어 알아보기<a hidden class=anchor aria-hidden=true href=#용어-알아보기>#</a></h3><h4 id=고가용성high-availability>고가용성(High Availability)<a hidden class=anchor aria-hidden=true href=#고가용성high-availability>#</a></h4><p>시스템이나 서비스가 가능한 한 오랫동안 중단 없이 운영될 수 있는 능력.</p><h4 id=결함-감내fault-tolerance>결함 감내(Fault Tolerance)<a hidden class=anchor aria-hidden=true href=#결함-감내fault-tolerance>#</a></h4><p>시스템이 일부 구성 요소의 장애에도 불구하고 정상적으로 동작할 수 있는 능력.</p><h1 id=이중화-사례>이중화 사례<a hidden class=anchor aria-hidden=true href=#이중화-사례>#</a></h1><p>한국에서는 너무도 유명해진 ‘카카오 데이터 센터 화재’ 사건이 있습니다.
2022년 10월 15일 15시 19분에 카카오가 사용중인 SK C&C 판교 데이터센터에 화재가 발생합니다.
이로 인해서 카카오톡을 포함한 카카오 전반적인 서비스에 장애가 발생하여 서비스가 중단되었습니다.
모든 서비스가 정상적으로 복구되기까지는 5일이 지난 10월 20일이었습니다.</p><p>카카오 서비스는 물론 이중화를 갖춘 시스템이었지만 완벽하지 않았습니다.
일부 이중화된 구성 요소와 장애 대응을 위한 도구가 판교 데이터 센터에만 있었고,
장애 모니터링과 자동화 프로세스가 미흡하였습니다.
결국 일부 서비스에 한해서는 판교 데이터 센터 자체가 SPoF인 상황에 놓이게 되었고,
여기서 장애가 발생하자 일부 서비스로 인해 전체 서비스가 중단되는 문제가 발생하였다고 볼 수 있습니다.</p><p>(카카오 서비스 장애 사건에 대해서는 <a href=https://www.kakaocorp.com/page/detail/9902>https://www.kakaocorp.com/page/detail/9902</a>
여기서 자세히 살펴볼 수 있습니다.)</p><p>이처럼 이중화는 서버를 2개 이상으로 구성만 했다고 해서 서비스를 안정적으로 유지할 수는 없습니다.
SPoF가 되는 부분을 모두 이중화를 해야하고, 데이터 센터조차도 이중화가 필요합니다.
그리고 이를 관리하기 위한 모니터링 구축도 필요합니다.
이중화는 비용이 매우 큰 작업이기 때문에 어쩔 수 없이 적절한 타협 지점을 찾아야할 지도 모릅니다.</p><h1 id=서버-이중화-구조>서버 이중화 구조<a hidden class=anchor aria-hidden=true href=#서버-이중화-구조>#</a></h1><p>일반적으로 서버를 이중화하는 구조는 크게 2가지로 나뉩니다.</p><ol><li>Active-Standby</li><li>Active-Active</li></ol><p>여기서 Active는 활성화가 되어있는 상태를 말합니다. 서버가 정상적으로 동작하고 있는 것입니다.</p><p>반면, Standby는 대기 상태로 말그대로 리소스는 차지하고 있지만 동작을 하고 있는 않은 상태입니다.</p><p><img loading=lazy src=images/single_server.png alt=single_server></p><p>위는 우리가 웹 요청을 받는 서버 구조를 매우 간단히 표현한 그림입니다.</p><p>만약 위로만 서버를 구성한다면, 장애가 발생하면 서비스는 중단됩니다. 바로 SPOF 문제죠.</p><p><img loading=lazy src=images/single_server_with_spof.png alt=single_server_with_spof></p><p>SPOF 문제를 해결하기 위해서 서버를 이중화해봅시다.</p><h2 id=active-standbypassive>Active-Standby(Passive)<a hidden class=anchor aria-hidden=true href=#active-standbypassive>#</a></h2><p><img loading=lazy src=images/active_standby.png alt=active_standby></p><p>같은 서버군을 물리적으로 분리하여 2개의 서버로 구성하였습니다.
Active-Standby는 하나의 서버는 활성화 상태로 사용하고,
하나는 장애 대비를 위해서 대기하는 서버입니다.</p><p>위 그림처럼 요청은 Active된 서버에서만 처리를 합니다.
만약 장애가 발생하면 대기하는 서버가 있기 때문에 빠르게 전환하여
서비스의 중단 시간을 최소화할 수 있습니다.
하지만 결국 전환 시간이 필요하기 때문에 서비스가 중단되는 시간이 필요합니다.</p><p>정리하면, Active-Standby 구조의 장단점은 다음과 같습니다.</p><ul><li>장점<ul><li>구조나 설정이 비교적 간단</li></ul></li><li>단점<ul><li>대기 서버는 비활성 상태에서 리소스가 계속 낭비</li><li>장애 발생 시 전환 시간이 필요</li></ul></li></ul><h3 id=용어-알아보기-1>용어 알아보기<a hidden class=anchor aria-hidden=true href=#용어-알아보기-1>#</a></h3><h4 id=failover-페일오버>Failover (페일오버)<a hidden class=anchor aria-hidden=true href=#failover-페일오버>#</a></h4><p>페일오버는 이중화된 시스템에서 하나의 구성 요소가 실패할 경우,
자동으로 대체 구성 요소로 전환하는 프로세스를 말합니다.</p><p>Active-Standby 이중화 구조에서 페일오버라고 하면,
Active 서버가 장애가 발생하여 Standby 서버가 대기 상태에서 활성화 상태로
변하면서 전환하는 과정을 의미합니다.</p><h4 id=failback-페일백>Failback (페일백)<a hidden class=anchor aria-hidden=true href=#failback-페일백>#</a></h4><p>페일백은 시스템이 장애로 인해 대체 시스템(또는 보조 시스템)으로 전환된 후,
원래의 주 시스템이 복구되었을 때 다시 원래 시스템으로 돌아가는 프로세스를 말합니다.</p><p>Active-Standby 이중화 구조에서 Active 서버가 장애가 발생하여 Standby 서버가
이를 대체한 후에 장애가 복구되어 다시 Active 였던 주 서버로 되돌아가는 과정을 말합니다.</p><h4 id=switchover-스위치오버>Switchover (스위치오버)<a hidden class=anchor aria-hidden=true href=#switchover-스위치오버>#</a></h4><p>페일오버가 장애가 발생하였을 때 자동으로 두 시스템 간의 전환이 이루어졌다면,
스위치오버는 자동이 아니라 수동으로 이 과정이 이루어지는 것을 말합니다.
이는 주로 계획된 유지보수나 업그레이드 또는 테스트 상황에서 사용됩니다.</p><h2 id=active-active>Active-Active<a hidden class=anchor aria-hidden=true href=#active-active>#</a></h2><p>앞서 살펴본 Active-Standby 구조에서 결국 장애 발생시 서비스가 중단이 된다는
치명적인 단점이 있었고, 리소스 역시 낭비되고 있었습니다.</p><p>이를 해결하기 위해 Active-Active 구조를 활용할 수 있습니다.</p><p><img loading=lazy src=images/active_active.png alt=active_active></p><p>Active-Active 구조는 2개의 서버가 모두 활성화되어 사용할 수 있는 구조입니다.
따라서 사용자 요청을 2개 서버에서 모두 처리할 수 있어 리소스가 낭비되지 않고 요청 처리량도 늘어납니다.</p><p>중요한 점은 만약 2개의 서버 중 하나가 장애가 발생하더라도 나머지 하나가
계속 활성화 상태로 처리할 수 있기 때문에 <strong>장애로 인한 서비스 중단이 발생하지 않습니다.</strong></p><p>그럼 여기서 한 가지 궁금증이 생길 수 있습니다.
&lsquo;물리적인 서버가 두 개가 되면 요청이 어디로 갈지 어떻게 중재해줄 수 있을까?&rsquo;
단순히 서버가 2개가 생긴다고 해서 SPOF를 해결했다고 볼 수는 없습니다.
요청이 들어왔을 때, 두 서버중에 어디로 가야할지 알아야 합니다.</p><p>서버는 물리적으로 분리가 되어있는 상태입니다.
즉, 각각의 서버의 MAC 주소가 분리되어 있는 상황이죠.
간단히 말하면 컴퓨터가 2대가 있는데 여기에 각각 서버가 구성되어 있는 환경입니다.
만약 요청이 들어왔을 때 이 컴퓨터 2대 중에 어디로 가야할지 결정을 해야합니다.</p><p>이 때 LACP(Link Aggregation Control Protocol)를 구성합니다.
LACP는 물리적인 네트워크 인터페이스를 묶어서 단일 논리적 링크를 구성하는 기술입니다.
이는 IEEE 802.3ad 표준으로 정의되어 있으며,
네트워크 스위치와 장비 간에 링크를 동적으로 결합하고 관리하는 프로토콜입니다.</p><p>LACP를 활용하여 2개의 물리 서버를 하나의 논리적인 장비로 묶어서
여기서 요청을 받아 어느 물리 서버로 보내야 할지 결정을 합니다.
일종의 로드밸런서와 같은 역할을 한다고 생각하면 이해하기 편할 것 같습니다.</p><p><img loading=lazy src=images/active_active_with_lacp.png alt=active_active_with_lacp></p><p>지금까지는 하드웨어 관점에서 살펴보았습니다.
소프트웨어 관점에서도 이중화가 필요합니다.
서버 개발자 입장에서는 이 부분을 직접 설정하고 활용해야할 때가 대부분일 것입니다.
특히, 클라우드와 쿠버네티스 환경이 대부분 자리잡은 상황에서 소프트웨어 이중화는
더욱 쉽고 편리하게 구성이 가능하게 되었습니다.</p><p><img loading=lazy src=images/active_active_add_software_redundancy.png alt=active_active_add_software_redundancy></p><ul><li>장점<ul><li>장애가 발생하더라도 중단없이 서비스 제공 가능</li><li>리소스를 효율적으로 사용 가능 (처리량 증가)</li></ul></li><li>단점<ul><li>추가적인 구성이 필요하고 설정이 복잡해짐.</li></ul></li></ul><h1 id=장애감지-모니터링>장애감지 모니터링<a hidden class=anchor aria-hidden=true href=#장애감지-모니터링>#</a></h1><p>이중화에서 중요한 요소 중 하나는 장애가 발생했을 때, 이를 감지하는 것입니다.
장애를 빨리 감지할수록 복구하는 비용이나 사용자의 불편함 등이 최소화되는 것은 당연합니다.</p><p>장애가 발생할 수 있는 지점은 크게 3가지 입니다.</p><ol><li>네트워크 장애</li><li>서버 물리 장비 장애</li><li>소프트웨어 (OS, 서버 애플리케이션 등) 장애</li></ol><p>이와 같이 지점에서 발생하는 장애를 감지하기 위해서는 크게 두 가지를 할 수 있습니다.</p><ol><li>Heartbeat 신호를 주기적으로 보내 정상 응답을 하는지 검사하기</li><li>시스템 로그에서 실시간으로 오류 메시지나 비정상적인 패턴이 발생하는지 검사하기</li></ol><p>위 두 가지를 검사하는 Agent를 장애가 발생할 수 있는 지점인 3 곳에 설치하여
이상이 있을 시에 알림을 받을 수 있도록 해야합니다.</p><p>이처럼 문제가 발생했을 때 알아차리는 것도 중요하지만,
문제가 발생할 수 있음을 짐작해서 미리 대비하는 것도 중요합니다.
이를 위해서는 CPU 및 메모리 사용량, 네트워크 트래픽, 디스크 I/O 및 애플리케이션 응답 시간 등
다양한 지표를 시각화하여 모니터링을 할 수 있어야 하고,
특정 임계치가 넘어갔을 때 알림을 준다거나 자동으로 자원을 정리하거나 서버를 재시작하는 등의
대응을 자동화해볼 수도 있습니다.</p><h1 id=데이터-복제>데이터 복제<a hidden class=anchor aria-hidden=true href=#데이터-복제>#</a></h1><p>이중화에서 2개 서버가 동일한 데이터에 항상 접근할 수 있어야 하는 데이터 무결성을 보장해야합니다.
위에서 이중화 구조 그림에서도 살펴보았지만,
데이터를 저장하고 있는 DB도 결국 서버이므로 이중화를 통해 고가용성을 보장해야합니다.
이로인해서 같은 데이터가 여러 곳에 있을 수 있기 때문에
<strong>데이터의 일관성을 보장</strong>하는 것이 중요합니다.</p><p>데이터 복제는 복제 중인 데이터가 시간이 지나면서 변경이 발생하기 때문에
이에 대한 데이터 일관성을 보장하기에는 많은 노력이 요구되고 트레이드오프가 발생합니다.</p><h1 id=dr-disaster-recover-재해-복구>DR (Disaster Recover, 재해 복구)<a hidden class=anchor aria-hidden=true href=#dr-disaster-recover-재해-복구>#</a></h1><p>이중화에서 더 나아가서 더 안전한 서버 환경을 구성하기 위해서는 DR을 구성할 수 있습니다.
DR은 자연재해나 인간의 행동(또는 실수)로 인한 재해가 발생한 후
IT 인프라에 대한 접근 및 기능을 복원할 수 있는 기능을 말합니다.</p><p>재해로 인해서 피해가 가장 크게 발생할 수 있는 곳이 물리 서버가 동작하고 있는 데이터 센터입니다.
만약 자연재해나 인재로 인해 데이터 센터 자체가 장애 상황이 발생한다면
이 데이터 센터 내에서 2개의 물리 장비를 사용하여 이중화를 하였다고 해도 무용지물입니다.
그래서 데이터 센터 자체를 이중화하여 DR을 수행할 수 있습니다.</p><p>DR을 위한 데이터 센터를 &lsquo;DR 센터&rsquo;라고도 부릅니다.
DR 센터는 백업을 위한 센터라고도 볼 수 있지만
사실 단순히 데이터 센터를 하나 더 사용하는 형태로도 볼 수 있습니다.
단, DR을 수행하기 위해서 두 데이터 센터는 물리적으로 떨어진 지역에 위치하고 있어야 합니다.
두 데이터 센터가 너무 가까이 있다면 재해 역시 같이 영향을 받을 확률이 크기 때문에
적당한 거리를 유지하는 것이 중요합니다.
(그렇다고 거리가 너무 멀게 되면 두 데이터 센터간 통신 속도나 실제 이동거리 등 효율이 매우 떨어질 수도 있습니다.)</p><p><img loading=lazy src=images/active_active_with_dr_center.png alt=active_active_with_dr_center></p><p>위는 이중화된 서버를 각각 두 개의 데이터 센터에 할당이 되어 있는 모습입니다.
DR을 만족하는 이중화라면 위처럼 물리 서버 장비 역시 각각의 데이터 센터에 존재하게 해야합니다.
만약 A 데이터센터에서 화재가 발생하여 먹통이 되더라도 B 데이터센터가 살아있기 때문에 서비스는
빠르게 장애를 극복할 수 있을 것입니다.</p><p>이러한 재해 복구 시스템은 복구 시간 및 시점에 따라 크게 4가지 유형으로 구분됩니다.</p><p>먼저, 유형을 살펴보기 전에 2개 용어를 살펴보겠습니다.</p><ul><li>RTO (Recovery Time Objective, 복구 시간 목표): 재해 발생 시 시스템이나 서비스가 복구되기까지 최대 시간.</li></ul><p>예를 들어, RTO가 4시간이면, 재해 발생 시 4시간 이내에 복구가 완료되는 것을 목표로 합니다.
따라서 그 시간 동안에는 서비스가 중단이 될 수 있습니다.</p><ul><li>RPO (Recovery Point Objective, 복구): 재해 발생 시 데이터 손실이 발생하는 최대 시간. 즉, 마지막 백업 시점과 재해 발생 시점 간의 데이터 손실 범위.</li></ul><p>예를들어, RPO가 4시간이면, 4시간 마다 백업을 합니다.
따라서 마지막 백업 이후 3시간 만에 재해가 발생했다면 이 3시간 동안의 데이터는 손실됩니다.</p><p><img loading=lazy src=images/rto_rpo.png alt=rto_rpo></p><p>RTO와 RPO에 따라 미러 사이트, 핫 사이트, 웜 사이트, 콜드 사이트 이렇게 4 가지 유형이 존재합니다.
(이 단계의 상세사항은 2007년 한국정보통신기술에서
제공한 <a href=https://cisp.or.kr/wp-content/uploads/2016/09/20160903_082806.pdf>정보시스템 재해 복구 지침</a>을 참고하였습니다.)</p><ul><li>[1등급] 미러 사이트 (Mirror Site)<ul><li>동일한 수준의 데이터 센터를 DR 센터로 두고, 두 데이터 센터를 Active-Active 구조로 구축합니다.</li><li>이 두 데이터 센터는 실시간 동기화가 이루어집니다.</li><li>RTO: 0 (이론상)</li><li>RPO: 0 (이론상)</li><li>장점: 장애가 발생하더라도 서비스 중단과 데이터 손실이 없습니다. (데이터 최신성, 높은 안정성)</li><li>단점: 초기 투자 및 유지보수 비용이 큽니다.</li></ul></li><li>[2등급] 핫 사이트 (Hot Site)<ul><li>동일한 수준의 데이터 센터를 DR 센터로 두고, 두 데이터 센터를 Active-Standby 구조로 구축합니다.</li><li>Active 중인 데이터 센터가 재해 발생 시 Standby에 있던 또 다른 데이터 센터를 Active로 전환하여 failover를 수행합니다.</li><li>RTO: 0</li><li>RPO: 수 시간 (보통 4시간)</li></ul></li><li>[3등급] 웜 사이트 (Warm Site)<ul><li>중요한 데이터만 부분적으로 DR 센터에 둡니다.</li><li>RTO: 수 일 ~ 수 주</li><li>RPO: 수 시간 ~ 1일</li></ul></li><li>[4등급] 콜드 사이트 (Cold Site)<ul><li>서비스에 필요한 최소한의 데이터만 DR 센터에 둡니다.</li><li>RTO: 수 주 ~ 수 개월</li><li>RPO: 수 일 ~ 수 주</li></ul></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/server/>Server</a></li><li><a href=https://parker1609.github.io/tags/redundancy/>Redundancy</a></li><li><a href=https://parker1609.github.io/tags/high-availability/>High Availability</a></li></ul><nav class=paginav><a class=next href=https://parker1609.github.io/post/foster-review/><span class=title>Next »</span><br><span>[도서 서평] - 맡겨진 소녀 - 클레어 키건</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>