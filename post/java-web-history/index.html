<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>자바 웹 기술 역사 | Parker Blog</title><meta name=keywords content="Java,Web,History"><meta name=description content="1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/java-web-history/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="자바 웹 기술 역사"><meta property="og:description" content="1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/java-web-history/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-02-26T14:45:58+09:00"><meta property="article:modified_time" content="2023-02-26T14:45:58+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="자바 웹 기술 역사"><meta name=twitter:description content="1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"자바 웹 기술 역사","item":"https://parker1609.github.io/post/java-web-history/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"자바 웹 기술 역사","name":"자바 웹 기술 역사","description":"1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다.","keywords":["Java","Web","History"],"articleBody":"1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다. 이런 동적인 페이지를 만들기 위해 초기에 CGI라는 일종의 규약을 만들었다. CGI는 동적인 페이지를 만드는 데 필요한 언어나 도구를 정의한 것이 아니라 동적인 페이지를 주고받는 규약이다. CGI에서 정의한 스팩이 있고, 이를 따라 구현된 프로그램은 CGI 프로그램이라고 부른다. CGI의 규칙은 간단하다.\n“정의한 URL로 요청이 오면, CGI 프로그램을 실행시켜 이 요청을 처리하고 그에 대한 응답 데이터를 반환다.”\n이 규칙을 다음과 같이 세 가지로 정리할 수 있다.\n메타데이터를 정의하였는가? 요청 방식을 정의하였는가? 요청에 대한 응답 방식을 정의하였는가? 위 세 가지를 정의하고 구현한 프로그램은 CGI 프로그램이다.\nCGI에 대해 알아보다 보면, 이를 구현하는 방식에 대해 서술하고 이를 단점이라고 말한다. 대표적으로 CGI 프로그램은 요청이 들어오면 새로운 ‘프로세스’를 생성하므로, 이 새로운 프로세스를 만드는 것에 대한 비용이 크기 때문에 단점이다. 그래서 현재에는 이를 대신하는 다른 기술을 사용한다고 한다.\n이는 CGI를 규약이 아닌 CGI가 나온 초기에 만들어진 CGI 프로그램에 대한 단점으로 보여진다. CGI는 구현 방식을 정의하지 않고 이는 사용자에게 맡기고 동적인 데이터를 주고 받는 것에 대한 규칙만을 설명한다. 위에 단점으로 말한 것은 예전에는 CGI 프로그램을 대부분 C 언어로 개발하였다. 그리고 그 당시 구현 방식은 C 언어로 새로운 프로세스를 생성하여 그 프로세스에 CGI 프로그램을 실행시켰다. 이에 대한 단점을 CGI 단점이라고 오해를 한 것으로 보인다. 아래 링크에서 CGI에 대한 설명을 보면 정의는 규약에 대한 것이며 단순하다.\nhttps://web.archive.org/web/20090409213905/http://hoohoo.ncsa.uiuc.edu/cgi/intro.html https://www.ibm.com/docs/en/i/7.4?topic=functionality-cgi https://en.wikipedia.org/wiki/Common_Gateway_Interface 참고로 https://kldp.org/node/73386 이 링크에서 댓글 토론을 보면서 CGI에 대한 이해도를 많이 높일 수 있었다.\n자바는 CGI 프로그램으로 Servlet(서블릿)이라는 이름으로 만들었다.\n서블릿에 대해서는 아래에 바로 자세히 다루겠지만, 서블릿의 정의를 찾아보면 ‘CGI 프로그램으로 자바에서 서블릿을 만들었다.’ 라는 말은 사실 찾아볼 수 없다.\n위는 개인적으로 CGI와 서블릿에 대해 각각 정의와 역할을 보았을 때, 서블릿은 CGI 프로그램으로 볼 수 있다고 정리를 했다. 대부분 책과 글에서는 CGI와 서블릿이 비슷할 뿐 ‘다른 것’이라고 말한다. 그 이유는 CGI는 프로세스를 새로 만들어 처리한다고 해서 이를 발전시킨 것이 서블릿이라고 말한다. 하지만 이는 위에서 설명했던 CGI에 대한 오해에서 시작한 것으로 보인다.\n2. Servlet (Jakarta Servlet / 전 Java Servlet, 서블릿) 서블릿은 CGI 프로그램 중 자바에서 구현한 것이라고 말했다. 좀 더 정확한 정의를 찾아보면, 오라클에서는 다음과 같이 정의하였다.\n“A servlet is a Java programming language class that is used to extend the capabilities of servers that host applications accessed by means of a request-response programming model. Although servlets can respond to any type of request, they are commonly used to extend the applications hosted by web servers. For such applications, Java Servlet technology defines HTTP-specific servlet classes.”\n-https://docs.oracle.com/javaee/5/tutorial/doc/bnafe.html\n서블릿은 요청-응답 모델에서 호스팅 애플리케이션(원격의 요청을 처리하는 애플리케이션) 역할을 하는 서버를 자바 프로그래밍으로 구현된 클래스이다. 서블릿은 모든 요청에 대한 응답을 처리할 수 있지만, 대부분 웹(HTTP) 요청을 처리하는 호스팅 애플리케이션으로 사용한다. 이러한 경우 자바 서블릿은 HTTP 요청을 처리하는 서블릿 클래스로 정의한다.\n서블릿은 모든 요청을 처리할 수 있다는 점에서 정적인 페이지와 동적인 페이지 모두 처리할 수 있다. 하지만 대부분 구현의 복잡도는 동적인 페이지를 구현하는 데 치중되어 있어 동적인 페이지를 만들기 위해서 대부분 사용한다. 이러한 점을 보았을 때, 서블릿은 CGI 프로그램 역할을 한다고 볼 수 있다.\n서블릿은 요청에 대해 필요한 로직을 처리하고 이에 대한 응답 데이터를 만들어 응답한다. 만약 서로 다른 요청이 여러 개라면, 각각 이를 처리하는 서블릿이 필요하다. 그리고 구현된 서블릿을 관리하는 것이 필요하다. URL로 요청이 왔을 때, 이 URL이 어떤 서블릿에서 처리해야 할지와 그 서블릿에 대한 생성 및 관리(라이프사이클)가 필요하다.\n이와 같은 서블릿을 관리하는 역할은 웹 컨테이너에서 수행한다. 그래서 서블릿을 배포하고 실행하려면 이 웹 컨테이너가 필수로 필요하다. 그러다보니 이를 서블릿 컨테이너라고도 부른다. 웹 컨테이너의 대표적인 예는 톰캣이 있다.\n웹 컨테이너는 대표적으로 다음과 같은 3가지 역할을 수행한다.\n서블릿의 라이프사이클을 관리한다. 요청 URL과 이를 처리하는 서블릿을 매핑한다. 요청한 클라이언트가 접근 권한이 있는지 확인한다. 위는 웹 컨테이너와 서블릿의 모습이다. 웹 요청이 왔을 때, 웹 컨테이너가 이를 받아서 어떤 서블릿에서 수행해야 할지 선택한다. 그리고 정의된 라이프사이클을 수행하여 웹 요청을 처리하고 서블릿을 관리한다.\n서블릿의 라이프사이클은 총 3가지이고, 다음과 같다.\ninit(): 서블릿에 필요한 설정 및 리소스 초기화를 담당한다. service(): 요청에 대한 처리 destory(): 현재 상태를 저장하고, 서블릿을 종료하기 위한 리소스 정리 서블릿의 라이프사이클을 바탕으로 웹 컨테이너는 클라이언트로부터 요청을 받았을 때, 다음과 같은 시나리오로 동작한다.\n클라이언트가 요청한 URL을 바탕으로 해당 요청을 처리할 서블릿을 매핑한다. 웹 컨테이너가 수행되고 처음 받은 요청인 경우(= 해당 서블릿이 처음 메모리에 올라간 경우), 서블릿 초기화를 수행한다. 해당 서블릿 클래스 정보를 가져온다. 메모리에 객체 인스턴스화를 수행한다. init() 메서드를 호출하여 필요한 초기화 과정을 수행한다. service() 메서드를 호출하여 요청을 처리하여 응답 데이터를 만들고 반환한다. 만약 웹 컨테이너에서 해당 서블릿을 종료하기로 결정한 경우, destroy() 메서드를 호출하여 서블릿 종료 과정을 수행한다. 서블릿 예제 코드 (위키 코드 참고: https://en.wikipedia.org/wiki/Jakarta_Servlet)\nimport java.io.IOException; import jakarta.servlet.ServletConfig; import jakarta.servlet.ServletException; import jakarta.servlet.http.HttpServlet; import jakarta.servlet.http.HttpServletRequest; import jakarta.servlet.http.HttpServletResponse; public class ServletLifeCycleExample extends HttpServlet { private Integer sharedCounter; @Override public void init(final ServletConfig config) throws ServletException { super.init(config); getServletContext().log(\"init() called\"); sharedCounter = 0; } @Override protected void service(final HttpServletRequest request, final HttpServletResponse response) throws ServletException, IOException { getServletContext().log(\"service() called\"); int localCounter; synchronized (sharedCounter) { sharedCounter++; localCounter = sharedCounter; } response.getWriter().write(\"Incrementing the count to \" + localCounter); // accessing a local variable // retrun html // response.getWriter().write(\"Result!\"); } @Override public void destroy() { getServletContext().log(\"destroy() called\"); } } Servlet 코드를 살펴보면, service() 메서드에서 HTML 결과를 만들어주고 있다. 자바 코드 내에 HTML 코드를 문자열로 관리하고 있는 것이다. 이는 관리면에서 매우 불편함을 주었다. 이를 해결해주기 위해 JSP가 나왔다.\n3. JSP (Jakarta Server Pages /전 JavaServer Pages) JSP는 HTML, XML 등 기반의 동적인 페이지를 만들어주는 도구이다. 위에서 설명했듯이, 서블릿을 사용해서 자바 코드 내에 HTML과 같은 뷰 페이지를 개발했던 것을 좀 더 편리하게 하기 위함이다. 실제로 JSP는 컴파일 이후에 실행가능한 서블릿 코드로 변경되어 사용된다.\nJSP는 서블릿과는 반대로 HTML과 같은 뷰 페이지 내에 자바 코드를 표현할 수 있는 문법으로 동작한다. 아래 예제를 간단히 살펴보자.\n\u003ctable\u003e \u003ctr align=\"center\"\u003e \u003ctd id=title\u003e아이디\u003c/td\u003e \u003ctd id=title\u003e비밀번호\u003c/td\u003e \u003ctd id=title\u003e이름\u003c/td\u003e \u003ctd id=title\u003e성별\u003c/td\u003e \u003ctd id=title\u003e생년월일\u003c/td\u003e \u003ctd id=title\u003e이메일\u003c/td\u003e \u003ctd id=title\u003e전화\u003c/td\u003e \u003ctd id=title\u003e주소\u003c/td\u003e \u003ctd id=title\u003e가입일\u003c/td\u003e \u003c/tr\u003e \u003c% for( MemberBean member : memberList){ %\u003e \u003ctr\u003e \u003ctd\u003e\u003c%=member.getId() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getPassword() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getName() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getGender() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getBirth() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getMail() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getPhone() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getAddress() %\u003e\u003c/td\u003e \u003ctd\u003e\u003c%=member.getReg() %\u003e\u003c/td\u003e \u003c/tr\u003e \u003c%} %\u003e \u003c/table\u003e 위는 서버에서 가져온 회원 정보 리스트를 HTML로 표현한 모습이다.\n자세한 문법은 https://docs.oracle.com/cd/B14099_19/web.1012/b14014/genlovw.htm 이 링크를 참고할 수 있다.\nJSP Model 1 Architecture JSP 모델 1 아키텍처는 JSP가 나온 초기의 아키텍처이다.\n이 아키텍처를 살펴보기 전에 웹 요청을 처리하는 데 일반적으로 사용하는 한 패턴을 살펴보자. 바로 MVC 패턴이다. 이는 웹을 처리하는 데 필요한 역할을 다음과 같이 각각 3가지로 나눈 것이다.\nModel: 요청을 처리하기 위한 로직 (비즈니스 로직) View: 요청의 결과를 보여주는 응답 화면 Contoller: 요청이 들어오면 이를 받아서 모델과 뷰를 사용하여 응답하기까지 흐름을 제어하는 역할 JSP 모델 1 아키텍처는 JSP 내에서 뷰와 컨트롤러 역할을 하였다. 그리고 모델은 단순히 자바 객체를 활용하여 구현하여 JSP에서 이를 가져다 쓰는 형식이다. (물론, 모델 역할까지 JSP에서도 할 수 있다.) 이를 그림으로 표현하면 다음과 같다.\nJSP: View + Controller 역할 JavaBeans (자바 빈 객체): 데이터 접근 + Model 역할 JSP 모델 1 아키텍처는 하나의 JSP에 대부분의 역할을 맡기기 때문에 구현이 매우 단순하다. 그래서 요청이 복잡하지 않은 경우에는 빠르게 구현할 수 있는 장점이 있다. 하지만, 늘그렇듯 하나에 모든 것이 담겨있으면 기능이 커질수록 복잡도가 올라간다. 그래서 요청이 복잡해지고 할 일이 많아지면 관리하기가 매우 힘들어진다는 단점이 있다.\n이를 해결하기 위해서 모델 2 아키텍처가 나왔다.\nJSP Model 2 Architecture JSP 모델 2 아키텍터는 모델 1에서 문제가 되었던 JSP의 복잡도가 높아지는 것을 해결하였다. JSP가 갖고 있던 역할을 분리한 것이다. JSP는 View 역할만 하고, Controller의 역할은 서블릿에게 맡기는 것이다. 아래 그림을 보자.\nController 역할을 서블릿에게 위임하여 분리하여 JSP가 갖고 있던 복잡도를 줄여 관리하기가 좀 더 용이해졌다.\n이 구조부터 MVC 각각의 역할을 나누었기 때문에 현재 흔히 말하는 MVC 패턴의 역할과 같다. JSP 모델 2 아키텍처를 기반으로 나온 프레임워크가 Apache Struts이다.\n스프링 프레임워크가 나온 초기에는 웹을 개발할 때 스프링 프레임워크 기반에 Spring MVC 대신 Apache Struts를 대부분 사용했다고 한다.\n그 외 Java View Template JSP 모델 2 아키텍처에서 JSP는 온전히 View 역할에 집중하게 된다. JSP 이 외에도 Java에서는 View 역할을 해주는 여럿 템플릿이 존재한다.\nThymeleaf Spring 프레임워크에서 공식 제공하는 템플릿 FreeMaker Velocity Groovy https://www.baeldung.com/spring-template-engines Spring MVC (with. Front Controller Pattern) Spring MVC는 스프링 프레임워크에서 제공하는 MVC 패턴으로 정식 명칭은 ‘Spring Web MVC’이다. 이름에서 알 수 있듯이, 웹 요청을 처리하는 MVC 패턴으로 구현되어 있고, 편리하게 웹 요청을 처리할 수 있게 도와준다.\nSpring Web MVC의 가장 큰 특징은 Front Controller Pattern을 도입한 MVC 패턴이다. 프론트 컨트롤러는 여러 곳에서 공통으로 사용하는 로직을 앞단의 컨트롤러로 분리하여 처리하여, 관리 및 개발 편리성을 높여준다. Spring Web MVC에서는 프론트 컨트롤러로 DispatcherServlet 클래스를 구현하였다.\nDispatcherServlet의 역할을 대표적으로 다음과 같다.\n모든 요청을 받아서 처리할 핸들러를 찾아서 매핑한다. (URL 기반) 공통적인 인증, 보안, 다국어 처리 등을 한다. 공통적인 응답 데이터(or 뷰)를 처리한다. 여기서 핸들러는 스프링 프레임워크에서 HandlerAdapter 인터페이스를 구현한 클래스입니다. 이는 여러 방법으로 스프링에 등록할 수 있는데, 최근에는 AnnotationMethodHandlerAdapter 이 방식을 기본적으로 사용합니다. 이는 @ReqeustMapping 애노테이션을 메서드에 붙여서, 해당 매서드에 웹 요청을 처리하는 로직을 선언하는 방법입니다.\n개인적인 생각으로 DispatcherServlet은 모든 요청 받아 URL 기반으로 처리할 핸들러를 찾아서 매핑해주는데, 이는 웹 컨테이너에서 하던 서블릿을 매핑하는 역할과 같다. 스프링 사용 전에는 웹 요청 처리를 서블릿이 담당했는데, 이를 스프링에서는 핸들러로 대체되었고, 그러면서 이 핸들러를 찾아주는 웹 컨테이너와 같은 기능이 필요했던 것으로 보인다. 이를 프론트 컨트롤러인 DispatcherServlet 에게 맡긴 것이다.\nSpring Boot 스프링 부트는 웹 컨테이너에 대해 신경쓰지 않고, 그 외에도 각종 스프링 설정을 자동으로 편리하게 설정할 수 있도록 도와준다. 톰캣(웹 컨테이너)를 내장하고 있다. 토비님 강의 모두 듣고 정리 예정 ","wordCount":"1515","inLanguage":"en","datePublished":"2023-02-26T14:45:58+09:00","dateModified":"2023-02-26T14:45:58+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/java-web-history/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/ title=Home><span>Home</span></a></li><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>자바 웹 기술 역사</h1><div class=post-meta><span title='2023-02-26 14:45:58 +0900 KST'>February 26, 2023</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#1-cgi-common-gateway-interface aria-label="1. CGI (Common Gateway Interface)">1. CGI (Common Gateway Interface)</a></li><li><a href=#2-servlethttpsenwikipediaorgwikijakarta_servlet-jakarta-servlet--%ec%a0%84-java-servlet-%ec%84%9c%eb%b8%94%eb%a6%bf aria-label="2. Servlet (Jakarta Servlet / 전 Java Servlet, 서블릿)">2. <a href=https://en.wikipedia.org/wiki/Jakarta_Servlet>Servlet</a> (Jakarta Servlet / 전 Java Servlet, 서블릿)</a></li><li><a href=#3-jsphttpsenwikipediaorgwikijakarta_server_pages-jakarta-server-pages-%ec%a0%84-javaserver-pages aria-label="3. JSP (Jakarta Server Pages /전 JavaServer Pages)">3. <a href=https://en.wikipedia.org/wiki/Jakarta_Server_Pages>JSP</a> (Jakarta Server Pages /전 JavaServer Pages)</a><ul><li><a href=#jsp-model-1-architecture aria-label="JSP Model 1 Architecture">JSP Model 1 Architecture</a></li><li><a href=#jsp-model-2-architecture aria-label="JSP Model 2 Architecture">JSP Model 2 Architecture</a></li><li><a href=#%ea%b7%b8-%ec%99%b8-java-view-template aria-label="그 외 Java View Template">그 외 Java View Template</a></li></ul></li><li><a href=#spring-mvc-with-front-controller-pattern aria-label="Spring MVC (with. Front Controller Pattern)">Spring MVC (with. Front Controller Pattern)</a></li><li><a href=#spring-boot aria-label="Spring Boot">Spring Boot</a></li></ul></div></details></div><div class=post-content><h1 id=1-cgi-common-gateway-interface>1. CGI (Common Gateway Interface)<a hidden class=anchor aria-hidden=true href=#1-cgi-common-gateway-interface>#</a></h1><p>World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다.
이런 동적인 페이지를 만들기 위해 초기에 CGI라는 일종의 규약을 만들었다. CGI는 동적인 페이지를 만드는 데 필요한 언어나 도구를 정의한 것이 아니라 <strong>동적인 페이지를 주고받는 규약</strong>이다.
CGI에서 정의한 스팩이 있고, 이를 따라 구현된 프로그램은 CGI 프로그램이라고 부른다. CGI의 규칙은 간단하다.</p><blockquote><p>&ldquo;정의한 URL로 요청이 오면, CGI 프로그램을 실행시켜 이 요청을 처리하고 그에 대한 응답 데이터를 반환다.&rdquo;</p></blockquote><p>이 규칙을 다음과 같이 세 가지로 정리할 수 있다.</p><ol><li>메타데이터를 정의하였는가?</li><li>요청 방식을 정의하였는가?</li><li>요청에 대한 응답 방식을 정의하였는가?</li></ol><p>위 세 가지를 정의하고 구현한 프로그램은 CGI 프로그램이다.</p><p>CGI에 대해 알아보다 보면, 이를 구현하는 방식에 대해 서술하고 이를 단점이라고 말한다. 대표적으로 CGI 프로그램은 요청이 들어오면 새로운 &lsquo;프로세스&rsquo;를 생성하므로, 이 새로운 프로세스를 만드는 것에 대한 비용이 크기 때문에 단점이다. 그래서 현재에는 이를 대신하는 다른 기술을 사용한다고 한다.</p><p>이는 CGI를 규약이 아닌 CGI가 나온 초기에 만들어진 CGI 프로그램에 대한 단점으로 보여진다. CGI는 구현 방식을 정의하지 않고 이는 사용자에게 맡기고 동적인 데이터를 주고 받는 것에 대한 규칙만을 설명한다. 위에 단점으로 말한 것은 예전에는 CGI 프로그램을 대부분 C 언어로 개발하였다. 그리고 그 당시 구현 방식은 C 언어로 새로운 프로세스를 생성하여 그 프로세스에 CGI 프로그램을 실행시켰다. 이에 대한 단점을 CGI 단점이라고 오해를 한 것으로 보인다. 아래 링크에서 CGI에 대한 설명을 보면 정의는 규약에 대한 것이며 단순하다.</p><ul><li><a href=https://web.archive.org/web/20090409213905/http://hoohoo.ncsa.uiuc.edu/cgi/intro.html>https://web.archive.org/web/20090409213905/http://hoohoo.ncsa.uiuc.edu/cgi/intro.html</a></li><li><a href="https://www.ibm.com/docs/en/i/7.4?topic=functionality-cgi">https://www.ibm.com/docs/en/i/7.4?topic=functionality-cgi</a></li><li><a href=https://en.wikipedia.org/wiki/Common_Gateway_Interface>https://en.wikipedia.org/wiki/Common_Gateway_Interface</a></li></ul><blockquote><p>참고로 <a href=https://kldp.org/node/73386>https://kldp.org/node/73386</a> 이 링크에서 댓글 토론을 보면서 CGI에 대한 이해도를 많이 높일 수 있었다.</p></blockquote><p>자바는 CGI 프로그램으로 Servlet(서블릿)이라는 이름으로 만들었다.</p><blockquote><p>서블릿에 대해서는 아래에 바로 자세히 다루겠지만, 서블릿의 정의를 찾아보면 &lsquo;CGI 프로그램으로 자바에서 서블릿을 만들었다.&rsquo; 라는 말은 사실 찾아볼 수 없다.</p><p>위는 개인적으로 CGI와 서블릿에 대해 각각 정의와 역할을 보았을 때, 서블릿은 CGI 프로그램으로 볼 수 있다고 정리를 했다. 대부분 책과 글에서는 CGI와 서블릿이 비슷할 뿐 &lsquo;다른 것&rsquo;이라고 말한다. 그 이유는 CGI는 프로세스를 새로 만들어 처리한다고 해서 이를 발전시킨 것이 서블릿이라고 말한다. 하지만 이는 위에서 설명했던 CGI에 대한 오해에서 시작한 것으로 보인다.</p></blockquote><h1 id=2-servlethttpsenwikipediaorgwikijakarta_servlet-jakarta-servlet--전-java-servlet-서블릿>2. <a href=https://en.wikipedia.org/wiki/Jakarta_Servlet>Servlet</a> (Jakarta Servlet / 전 Java Servlet, 서블릿)<a hidden class=anchor aria-hidden=true href=#2-servlethttpsenwikipediaorgwikijakarta_servlet-jakarta-servlet--전-java-servlet-서블릿>#</a></h1><p>서블릿은 CGI 프로그램 중 자바에서 구현한 것이라고 말했다. 좀 더 정확한 정의를 찾아보면, 오라클에서는 다음과 같이 정의하였다.</p><blockquote><p>&ldquo;A servlet is a Java programming language class that is used to extend the capabilities of servers that host applications accessed by means of a request-response programming model. Although servlets can respond to any type of request, they are commonly used to extend the applications hosted by web servers. For such applications, Java Servlet technology defines HTTP-specific servlet classes.&rdquo;</p><p>-<a href=https://docs.oracle.com/javaee/5/tutorial/doc/bnafe.html>https://docs.oracle.com/javaee/5/tutorial/doc/bnafe.html</a></p><p>서블릿은 요청-응답 모델에서 호스팅 애플리케이션(원격의 요청을 처리하는 애플리케이션) 역할을 하는 서버를 자바 프로그래밍으로 구현된 클래스이다. 서블릿은 모든 요청에 대한 응답을 처리할 수 있지만, 대부분 웹(HTTP) 요청을 처리하는 호스팅 애플리케이션으로 사용한다. 이러한 경우 자바 서블릿은 HTTP 요청을 처리하는 서블릿 클래스로 정의한다.</p></blockquote><p>서블릿은 모든 요청을 처리할 수 있다는 점에서 정적인 페이지와 동적인 페이지 모두 처리할 수 있다. 하지만 대부분 구현의 복잡도는 동적인 페이지를 구현하는 데 치중되어 있어 동적인 페이지를 만들기 위해서 대부분 사용한다. 이러한 점을 보았을 때, 서블릿은 CGI 프로그램 역할을 한다고 볼 수 있다.</p><p>서블릿은 요청에 대해 필요한 로직을 처리하고 이에 대한 응답 데이터를 만들어 응답한다. 만약 서로 다른 요청이 여러 개라면, 각각 이를 처리하는 서블릿이 필요하다. 그리고 구현된 서블릿을 관리하는 것이 필요하다. URL로 요청이 왔을 때, 이 URL이 어떤 서블릿에서 처리해야 할지와 그 서블릿에 대한 생성 및 관리(라이프사이클)가 필요하다.</p><p>이와 같은 서블릿을 관리하는 역할은 <a href=https://en.wikipedia.org/wiki/Web_container>웹 컨테이너</a>에서 수행한다. 그래서 서블릿을 배포하고 실행하려면 이 웹 컨테이너가 필수로 필요하다. 그러다보니 이를 서블릿 컨테이너라고도 부른다. 웹 컨테이너의 대표적인 예는 톰캣이 있다.</p><p>웹 컨테이너는 대표적으로 다음과 같은 3가지 역할을 수행한다.</p><ul><li>서블릿의 라이프사이클을 관리한다.</li><li>요청 URL과 이를 처리하는 서블릿을 매핑한다.</li><li>요청한 클라이언트가 접근 권한이 있는지 확인한다.</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/221331504-dc4302b4-4af2-4b92-8187-da35be788cd6.png alt=web-container></p><p>위는 웹 컨테이너와 서블릿의 모습이다. 웹 요청이 왔을 때, 웹 컨테이너가 이를 받아서 어떤 서블릿에서 수행해야 할지 선택한다. 그리고 정의된 라이프사이클을 수행하여 웹 요청을 처리하고 서블릿을 관리한다.</p><p>서블릿의 라이프사이클은 총 3가지이고, 다음과 같다.</p><ul><li><code>init()</code>: 서블릿에 필요한 설정 및 리소스 초기화를 담당한다.</li><li><code>service()</code>: 요청에 대한 처리</li><li><code>destory()</code>: 현재 상태를 저장하고, 서블릿을 종료하기 위한 리소스 정리</li></ul><p>서블릿의 라이프사이클을 바탕으로 웹 컨테이너는 클라이언트로부터 요청을 받았을 때, 다음과 같은 시나리오로 동작한다.</p><ol><li>클라이언트가 요청한 URL을 바탕으로 해당 요청을 처리할 서블릿을 매핑한다.</li><li>웹 컨테이너가 수행되고 처음 받은 요청인 경우(= 해당 서블릿이 처음 메모리에 올라간 경우), 서블릿 초기화를 수행한다.<ol><li>해당 서블릿 클래스 정보를 가져온다.</li><li>메모리에 객체 인스턴스화를 수행한다.</li><li><code>init()</code> 메서드를 호출하여 필요한 초기화 과정을 수행한다.</li></ol></li><li><code>service()</code> 메서드를 호출하여 요청을 처리하여 응답 데이터를 만들고 반환한다.</li><li>만약 웹 컨테이너에서 해당 서블릿을 종료하기로 결정한 경우, <code>destroy()</code> 메서드를 호출하여 서블릿 종료 과정을 수행한다.</li></ol><p>서블릿 예제 코드 (위키 코드 참고: <a href=https://en.wikipedia.org/wiki/Jakarta_Servlet>https://en.wikipedia.org/wiki/Jakarta_Servlet</a>)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kn>import</span> <span class=nn>java.io.IOException</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>jakarta.servlet.ServletConfig</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>jakarta.servlet.ServletException</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>jakarta.servlet.http.HttpServlet</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>jakarta.servlet.http.HttpServletRequest</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=nn>jakarta.servlet.http.HttpServletResponse</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ServletLifeCycleExample</span> <span class=kd>extends</span> <span class=n>HttpServlet</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Integer</span> <span class=n>sharedCounter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>init</span><span class=o>(</span><span class=kd>final</span> <span class=n>ServletConfig</span> <span class=n>config</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>ServletException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kd>super</span><span class=o>.</span><span class=na>init</span><span class=o>(</span><span class=n>config</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>getServletContext</span><span class=o>().</span><span class=na>log</span><span class=o>(</span><span class=s>&#34;init() called&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=n>sharedCounter</span> <span class=o>=</span> <span class=mi>0</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>protected</span> <span class=kt>void</span> <span class=nf>service</span><span class=o>(</span><span class=kd>final</span> <span class=n>HttpServletRequest</span> <span class=n>request</span><span class=o>,</span> <span class=kd>final</span> <span class=n>HttpServletResponse</span> <span class=n>response</span><span class=o>)</span> <span class=kd>throws</span> <span class=n>ServletException</span><span class=o>,</span> <span class=n>IOException</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>getServletContext</span><span class=o>().</span><span class=na>log</span><span class=o>(</span><span class=s>&#34;service() called&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>int</span> <span class=n>localCounter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=kd>synchronized</span> <span class=o>(</span><span class=n>sharedCounter</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>sharedCounter</span><span class=o>++;</span>
</span></span><span class=line><span class=cl>            <span class=n>localCounter</span> <span class=o>=</span> <span class=n>sharedCounter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>        <span class=n>response</span><span class=o>.</span><span class=na>getWriter</span><span class=o>().</span><span class=na>write</span><span class=o>(</span><span class=s>&#34;Incrementing the count to &#34;</span> <span class=o>+</span> <span class=n>localCounter</span><span class=o>);</span>  <span class=c1>// accessing a local variable
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>        <span class=c1>// retrun html
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=c1>// response.getWriter().write(&#34;&lt;html&gt;&lt;body&gt;Result!&lt;/body&gt;&lt;/html&gt;&#34;);
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>destroy</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>getServletContext</span><span class=o>().</span><span class=na>log</span><span class=o>(</span><span class=s>&#34;destroy() called&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Servlet 코드를 살펴보면, <code>service()</code> 메서드에서 HTML 결과를 만들어주고 있다. 자바 코드 내에 HTML 코드를 문자열로 관리하고 있는 것이다. 이는 관리면에서 매우 불편함을 주었다. 이를 해결해주기 위해 JSP가 나왔다.</p><h1 id=3-jsphttpsenwikipediaorgwikijakarta_server_pages-jakarta-server-pages-전-javaserver-pages>3. <a href=https://en.wikipedia.org/wiki/Jakarta_Server_Pages>JSP</a> (Jakarta Server Pages /전 JavaServer Pages)<a hidden class=anchor aria-hidden=true href=#3-jsphttpsenwikipediaorgwikijakarta_server_pages-jakarta-server-pages-전-javaserver-pages>#</a></h1><p>JSP는 HTML, XML 등 기반의 동적인 페이지를 만들어주는 도구이다. 위에서 설명했듯이, 서블릿을 사용해서 자바 코드 내에 HTML과 같은 뷰 페이지를 개발했던 것을 좀 더 편리하게 하기 위함이다. 실제로 <strong>JSP는 컴파일 이후에 실행가능한 서블릿 코드로 변경되어 사용된다.</strong></p><p>JSP는 서블릿과는 반대로 HTML과 같은 뷰 페이지 내에 자바 코드를 표현할 수 있는 문법으로 동작한다. 아래 예제를 간단히 살펴보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-html data-lang=html><span class=line><span class=cl><span class=p>&lt;</span><span class=nt>table</span><span class=p>&gt;</span>    
</span></span><span class=line><span class=cl>   <span class=p>&lt;</span><span class=nt>tr</span> <span class=na>align</span><span class=o>=</span><span class=s>&#34;center&#34;</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>아이디<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>비밀번호<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>이름<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>성별<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>생년월일<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>이메일<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>전화<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>주소<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span> <span class=na>id</span><span class=o>=</span><span class=s>title</span><span class=p>&gt;</span>가입일<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=p>&lt;/</span><span class=nt>tr</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=err>&lt;</span>%
</span></span><span class=line><span class=cl>   for( MemberBean member : memberList){
</span></span><span class=line><span class=cl>%&gt;            
</span></span><span class=line><span class=cl>   <span class=p>&lt;</span><span class=nt>tr</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getId() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getPassword() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getName() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getGender() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getBirth() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getMail() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getPhone() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getAddress() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>       <span class=p>&lt;</span><span class=nt>td</span><span class=p>&gt;</span><span class=err>&lt;</span>%=member.getReg() %&gt;<span class=p>&lt;/</span><span class=nt>td</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl>   <span class=p>&lt;/</span><span class=nt>tr</span><span class=p>&gt;</span>
</span></span><span class=line><span class=cl><span class=err>&lt;</span>%} %&gt;    
</span></span><span class=line><span class=cl><span class=p>&lt;/</span><span class=nt>table</span><span class=p>&gt;</span>
</span></span></code></pre></div><p>위는 서버에서 가져온 회원 정보 리스트를 HTML로 표현한 모습이다.</p><p>자세한 문법은 <a href=https://docs.oracle.com/cd/B14099_19/web.1012/b14014/genlovw.htm>https://docs.oracle.com/cd/B14099_19/web.1012/b14014/genlovw.htm</a> 이 링크를 참고할 수 있다.</p><h2 id=jsp-model-1-architecture>JSP Model 1 Architecture<a hidden class=anchor aria-hidden=true href=#jsp-model-1-architecture>#</a></h2><p>JSP 모델 1 아키텍처는 JSP가 나온 초기의 아키텍처이다.</p><p>이 아키텍처를 살펴보기 전에 웹 요청을 처리하는 데 일반적으로 사용하는 한 패턴을 살펴보자. 바로 <strong>MVC 패턴</strong>이다. 이는 웹을 처리하는 데 필요한 역할을 다음과 같이 각각 3가지로 나눈 것이다.</p><ul><li>Model: 요청을 처리하기 위한 로직 (비즈니스 로직)</li><li>View: 요청의 결과를 보여주는 응답 화면</li><li>Contoller: 요청이 들어오면 이를 받아서 모델과 뷰를 사용하여 응답하기까지 흐름을 제어하는 역할</li></ul><p>JSP 모델 1 아키텍처는 JSP 내에서 뷰와 컨트롤러 역할을 하였다. 그리고 모델은 단순히 자바 객체를 활용하여 구현하여 JSP에서 이를 가져다 쓰는 형식이다. (물론, 모델 역할까지 JSP에서도 할 수 있다.)
이를 그림으로 표현하면 다음과 같다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/221388529-28b6e540-6ab8-4f37-b030-03e03576424d.png alt=jsp-model-1></p><ul><li>JSP: View + Controller 역할</li><li>JavaBeans (자바 빈 객체): 데이터 접근 + Model 역할</li></ul><p>JSP 모델 1 아키텍처는 하나의 JSP에 대부분의 역할을 맡기기 때문에 구현이 매우 단순하다. 그래서 요청이 복잡하지 않은 경우에는 빠르게 구현할 수 있는 장점이 있다. 하지만, 늘그렇듯 하나에 모든 것이 담겨있으면 기능이 커질수록 복잡도가 올라간다. 그래서 요청이 복잡해지고 할 일이 많아지면 관리하기가 매우 힘들어진다는 단점이 있다.</p><p>이를 해결하기 위해서 모델 2 아키텍처가 나왔다.</p><h2 id=jsp-model-2-architecture>JSP Model 2 Architecture<a hidden class=anchor aria-hidden=true href=#jsp-model-2-architecture>#</a></h2><p>JSP 모델 2 아키텍터는 모델 1에서 문제가 되었던 JSP의 복잡도가 높아지는 것을 해결하였다. JSP가 갖고 있던 역할을 분리한 것이다. JSP는 View 역할만 하고, Controller의 역할은 서블릿에게 맡기는 것이다. 아래 그림을 보자.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/221389092-0d0acc89-8cfa-473b-a696-8d64c4e9cb10.png alt=jsp-model-2></p><p>Controller 역할을 서블릿에게 위임하여 분리하여 JSP가 갖고 있던 복잡도를 줄여 관리하기가 좀 더 용이해졌다.</p><p>이 구조부터 MVC 각각의 역할을 나누었기 때문에 현재 흔히 말하는 MVC 패턴의 역할과 같다. JSP 모델 2 아키텍처를 기반으로 나온 프레임워크가 <a href=https://struts.apache.org/>Apache Struts</a>이다.</p><blockquote><p>스프링 프레임워크가 나온 초기에는 웹을 개발할 때 스프링 프레임워크 기반에 Spring MVC 대신 Apache Struts를 대부분 사용했다고 한다.</p></blockquote><h2 id=그-외-java-view-template>그 외 Java View Template<a hidden class=anchor aria-hidden=true href=#그-외-java-view-template>#</a></h2><p>JSP 모델 2 아키텍처에서 JSP는 온전히 View 역할에 집중하게 된다. JSP 이 외에도 Java에서는 View 역할을 해주는 여럿 템플릿이 존재한다.</p><ul><li>Thymeleaf<ul><li>Spring 프레임워크에서 공식 제공하는 템플릿</li></ul></li><li>FreeMaker</li><li>Velocity</li><li>Groovy</li><li><a href=https://www.baeldung.com/spring-template-engines>https://www.baeldung.com/spring-template-engines</a></li></ul><h1 id=spring-mvc-with-front-controller-pattern>Spring MVC (with. Front Controller Pattern)<a hidden class=anchor aria-hidden=true href=#spring-mvc-with-front-controller-pattern>#</a></h1><p>Spring MVC는 스프링 프레임워크에서 제공하는 MVC 패턴으로 정식 명칭은 &lsquo;Spring Web MVC&rsquo;이다. 이름에서 알 수 있듯이, 웹 요청을 처리하는 MVC 패턴으로 구현되어 있고, 편리하게 웹 요청을 처리할 수 있게 도와준다.</p><p>Spring Web MVC의 가장 큰 특징은 <a href=https://en.wikipedia.org/wiki/Front_controller>Front Controller Pattern</a>을 도입한 MVC 패턴이다. 프론트 컨트롤러는 여러 곳에서 공통으로 사용하는 로직을 앞단의 컨트롤러로 분리하여 처리하여, 관리 및 개발 편리성을 높여준다. Spring Web MVC에서는 프론트 컨트롤러로 <code>DispatcherServlet</code> 클래스를 구현하였다.</p><p><code>DispatcherServlet</code>의 역할을 대표적으로 다음과 같다.</p><ul><li>모든 요청을 받아서 처리할 핸들러를 찾아서 매핑한다. (URL 기반)</li><li>공통적인 인증, 보안, 다국어 처리 등을 한다.</li><li>공통적인 응답 데이터(or 뷰)를 처리한다.</li></ul><p>여기서 핸들러는 스프링 프레임워크에서 <code>HandlerAdapter</code> 인터페이스를 구현한 클래스입니다. 이는 여러 방법으로 스프링에 등록할 수 있는데, 최근에는 <code>AnnotationMethodHandlerAdapter</code> 이 방식을 기본적으로 사용합니다. 이는 <code>@ReqeustMapping</code> 애노테이션을 메서드에 붙여서, 해당 매서드에 웹 요청을 처리하는 로직을 선언하는 방법입니다.</p><blockquote><p>개인적인 생각으로 <code>DispatcherServlet</code>은 모든 요청 받아 URL 기반으로 처리할 핸들러를 찾아서 매핑해주는데, 이는 웹 컨테이너에서 하던 서블릿을 매핑하는 역할과 같다. 스프링 사용 전에는 웹 요청 처리를 서블릿이 담당했는데, 이를 스프링에서는 핸들러로 대체되었고, 그러면서 이 핸들러를 찾아주는 웹 컨테이너와 같은 기능이 필요했던 것으로 보인다. 이를 프론트 컨트롤러인 <code>DispatcherServlet</code> 에게 맡긴 것이다.</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/221393483-e1ab1b78-e605-4631-978d-08b5854ff432.png alt=spring-web-mvc></p><h1 id=spring-boot>Spring Boot<a hidden class=anchor aria-hidden=true href=#spring-boot>#</a></h1><ul><li>스프링 부트는 웹 컨테이너에 대해 신경쓰지 않고, 그 외에도 각종 스프링 설정을 자동으로 편리하게 설정할 수 있도록 도와준다.</li><li>톰캣(웹 컨테이너)를 내장하고 있다.</li><li>토비님 강의 모두 듣고 정리 예정</li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/java/>Java</a></li><li><a href=https://parker1609.github.io/tags/web/>Web</a></li><li><a href=https://parker1609.github.io/tags/history/>History</a></li></ul><nav class=paginav><a class=prev href=https://parker1609.github.io/post/kafka-101/><span class=title>« Prev</span><br><span>[Kafka] 101 - 카프카에 대한 소개와 주요 설정</span></a>
<a class=next href=https://parker1609.github.io/post/java-11-vs-java-17/><span class=title>Next »</span><br><span>Java 11 vs Java 17</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>