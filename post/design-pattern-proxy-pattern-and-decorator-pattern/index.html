<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[디자인 패턴] 프록시 패턴/데코레이터 패턴 | Parker Blog</title><meta name=keywords content="Design Pattern,Proxy Pattern,Decorator Pattern,Java"><meta name=description content="이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.
프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.
접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[디자인 패턴] 프록시 패턴/데코레이터 패턴"><meta property="og:description" content="이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.
프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.
접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2022-08-25T09:12:33+09:00"><meta property="article:modified_time" content="2022-08-25T09:12:33+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[디자인 패턴] 프록시 패턴/데코레이터 패턴"><meta name=twitter:description content="이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.
프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.
접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"[디자인 패턴] 프록시 패턴/데코레이터 패턴","item":"https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[디자인 패턴] 프록시 패턴/데코레이터 패턴","name":"[디자인 패턴] 프록시 패턴\/데코레이터 패턴","description":"이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자\u0026rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.\n프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.\n접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다.","keywords":["Design Pattern","Proxy Pattern","Decorator Pattern","Java"],"articleBody":"이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자’라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.\n프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.\n접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다. 이 의도는 프록시의 기능에 따라 나누고 있다.\n프록시 패턴 → 접근 제어 데코레이터 패턴 → 부가 기능 추가 두 패턴 모두 프록시를 사용하므로, 사실 구현 방법은 동일하다.\n클라이언트는 원래 RealSubject를 사용해야 하지만, 접근 제어 또는 부가 기능을 위해 프록시를 추가하려고 한다. 클라이언트의 코드 변경없이 RealSubject 대신 프록시 객체를 사용하려면, 두 객체는 같은 타입으로 추상화되어야 한다. 따라서, 프록시를 사용하는 클래스 의존 관계는 위처럼 같은 타입의 인터페이스를 추상화하여 사용하게 된다. 이를 런타임 객체 의존 관계를 보면 프록시의 관계가 좀 더 명확하게 보일 것이다.\n클라이언트가 런타임에서 실제로 사용하는 객체는 프록시 객체이고, 프록시 객체 내에서 접근 제어 또는 부가 기능을 수행한 후, 프록시가 실제 객체인 RealSubject 기능을 수행하게 된다.\n지금까지 프록시에 대해서 알아보았고, 이제 예제를 통해 프록시 패턴과 데코레이터 패턴이 어떻게 사용되는지 살펴보자.\n전체 코드는 이 링크에서 볼 수 있습니다.\n프록시 패턴 (Proxy Pattern) 프록시 패턴의 대표적인 예는 캐시가 있다. 캐시는 이미 데이터가 있으면, 기존의 데이터를 사용하고 없으면 새로 만든다. 코드 구조는 위에서 살펴본 Subject 인터페이스를 기반으로 한 모습과 동일하다.\npublic interface Subject { String operation(); } operation() 메서드를 호출하면, 반환값으로 문자열 데이터를 받는다. @Slf4j public class RealSubject implements Subject { @Override public String operation() { log.info(\"RealSubject 호출\"); return \"data\"; } } RealSubject 클래스는 Subject 인터페이스를 구현하고, 데이터를 실제로 만드는 역할을 한다. @Slf4j public class CacheProxySubject implements Subject { private Subject target; private String cacheValue; public CacheProxySubject(Subject target) { this.target = target; } @Override public String operation() { log.info(\"캐시 프록시 호출\"); if (cacheValue == null) { log.info(\"캐시 값이 비어있으므로, 새로 생성\"); cacheValue = target.operation(); } return cacheValue; } } CacheProxySubject 클래스도 역시 Subject 인터페이스를 구현하지만, 캐시 기능을 하는 프록시이다. 필드로 가지고 있는 cacheValue 문자열이 비어있으면, 실제 RealSubject 를 호출하여 데이터를 만든다. cacheValue 가 비어있지 않으면, 현재 가지고 있는 것을 그대로 반환한다. 캐시 역할을 하는 프록시 패턴의 구현체는 모두 완성하였다. 이를 호출하는 클라이언트를 테스트 코드로 작성해보자.\n@Test void use_proxy_pattern() { Subject realSubject = new RealSubject(); Subject cacheProxy = new CacheProxySubject(realSubject); // 처음 프록시 호출로 RealSubject를 호출하여 실제 데이터를 가져온다. log.info(\"----- 클라이언트에서 첫 번째 호출 -----\"); cacheProxy.operation(); // 두번째 호출부터는 RealSubject를 호출하지 않고, 캐시값을 사용한다. log.info(\"----- 클라이언트에서 두 번째 호출 -----\"); cacheProxy.operation(); } ----- 클라이언트에서 첫 번째 호출 ----- 캐시 프록시 호출 캐시 값이 비어있으므로, 새로 생성 RealSubject 호출 ----- 클라이언트에서 두 번째 호출 ----- 캐시 프록시 호출 결과를 보면, 처음 호출할 때는 캐시 프록시에 데이터가 없으므로 실제 Subject 구현체를 호출하여 데이터를 생성한다. 하지만 두 번째 호출부터는 실제 Subject 구현체를 전혀 사용하지 않고, 가지고 있는 데이터를 캐싱해서 반환하고 있다.\n데코레이터 패턴 (Decorator Pattern) 데코레이터 패턴은 기능 추가를 실제 로직 변경없이, 프록시 형태로 독립된 곳에서 수행을 할 수 있다보니 활용도가 매우 높다. 이 글의 예제에서는 이전에 살펴보았던 디자인 패턴 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴 글에서 사용한 예제에서 기능을 추가해보자.\n이전 예제에서 문자 알림을 전송하기 위해 SmsService 클래스의 sendSms() 메서드가 전체 전송 기능을 담당하고 있었다. (전략 패턴 예제 기준)\npublic void sendSms(String cellphoneNumber, String smsContents) { log.info(\"문자 발송 시작\"); long startTime = System.currentTimeMillis(); boolean result = smsSendingStrategy.execute(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } 위 메서드 코드에서 실제로 문자 알림을 전송하는 부분은 smsSendingStrategy.execute() 메서드이다. 이 메서드를 호출하기 전에 알림을 실제로 보낼 수 있는 상태인지를 체크해야 하는 요구사항이 발생했다고 가정해보자.\n문자를 포함한 모든 알림은 회원 상태가 NORMAL 인 경우에만 전송한다. 문자 알림 전송은 유선 번호인 경우에는 제외한다. 첫 번째 요구사항은 문자 외에도 이메일이나 앱푸시와 같은 모든 알림 수단에 공통적으로 체크해야 하는 사항이고, 두 번째 요구사항은 문자 알림에 특화된 체크사항이다. 이러한 상태 체크는 추가되거나 변경되는 일이 빈번하고, 알림 수단마다 공통적으로 필요한 것도 있다. 이러한 요구사항을 유연하게 대처하려면 어떻게 해야할까?\n여기서는 데코레이터 패턴을 사용하여 이러한 요구사항을 유연하게 대처해보자.\n데코레이터 패턴도 이 글 처음 프록시에 대해 살펴보았던 것처럼 클래스 구조는 동일하다. 위 요구사항을 바탕으로 다시 클래스 구조를 그려보자.\nNotificationFilter : 전송할 수 있는지 체크하는 역할의 이름을 필터라고 두고, 알림을 전송할 수 있는지 검사하는 필터 인터페이스이다. CommonFilter: 모든 알림 수단에서 공통적으로 검사하는 필터로, 디폴트 필터 역할을 한다. 회원 상태가 NORMAL 인지 검사 SmsFilterDecorator: 문자 알림에만 필요한 체크사항을 검사하는 필터 역할을 한다. 휴대폰 번호가 정확한지 검사 위를 코드로 구현해보자. 먼저, 문자 전송을 담당하는 SmsService 클래스 전체 코드는 다음과 같다.\n@Slf4j public class SmsService { private final SmsSendingStrategy smsSendingStrategy; private final NotificationFilter notificationFilter; public SmsService(SmsSendingStrategy smsSendingStrategy, NotificationFilter notificationFilter) { this.smsSendingStrategy = smsSendingStrategy; this.notificationFilter = notificationFilter; } public void sendSms(NotificationRequest request) { log.info(\"문자 발송 시작\"); long startTime = System.currentTimeMillis(); if (!notificationFilter.canSend(request)) { log.info(\"문자를 발송할 수 없는 상태입니다.\"); return; } boolean result = smsSendingStrategy.execute(request.getCellphoneNumber(), request.getSmsContents()); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } } 데코레이터 패턴을 적용한 알림 필터(NotificationFilter)가 필드로 추가되었다. 회원 상태 검사를 위한 데이터를 추가해야하는데, 이를 원래 알림에 필요한 데이터와 함께 NotificationRequest 클래스로 추출하였다. (아래 코드 참고) 필터가 적용되는 시점은 실제 전송하기 전에 검사를 한다. @AllArgsConstructor @NoArgsConstructor @Getter @ToString public class NotificationRequest { private String memberStatus; private String cellphoneNumber; private String smsContents; } 회원 상태를 담고 있는 membserStatus 필드가 추가되었다. (사실, 문자열보다는 enum으로 관리하는 것이 훨씬 유연하게 상태를 관리할 수 있다.) 데코레이터 패턴의 핵심인 알림 필터 코드는 다음과 같다.\npublic interface NotificationFilter { boolean canSend(NotificationRequest request); } public class CommonFilter implements NotificationFilter { @Override public boolean canSend(NotificationRequest request) { return \"NORMAL\".equals(request.getMemberStatus()); } } public class SmsFilterDecorator implements NotificationFilter { private static final Pattern CELLPHONE_NUMBER_PATTERN = Pattern.compile(\"^01(?:0|1|[6-9])-(?:\\\\d{3}|\\\\d{4})-\\\\d{4}$\"); private final NotificationFilter notificationFilter; public SmsFilterDecorator(NotificationFilter notificationFilter) { this.notificationFilter = notificationFilter; } @Override public boolean canSend(NotificationRequest request) { boolean result = notificationFilter.canSend(request); if (!result) { return false; } Matcher matcher = CELLPHONE_NUMBER_PATTERN.matcher(request.getCellphoneNumber()); return matcher.find(); } } 기존 공통 알림 필터 기능에 문자 알림을 위한 필터 기능이 추가되었다. (공통 알림 필터가 아닌 이전에 추가된 데코레이터 필터 기능으로도 볼 수 있다.) 마지막으로, 이를 사용하는 클라이언트 코드를 살펴보자. 총 3가지 경우를 살펴보는 것이 데코레이터 패턴이 정상적으로 적용되었는지 확인할 수 있을 것이다.\n정상적으로 문자 알림을 발송하는 경우 회원 상태가 NORMAL 이 아니어서, 문자 발송을 하지 않는 경우 휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우 1. 정상적으로 문자 알림을 발송하는 경우 @Test void success_sending_sms() { SmsSendingStrategy smsSendingStrategy = new SmsSendingStrategyA(); // 필터 설정 NotificationFilter commonFiler = new CommonFilter(); NotificationFilter smsFilter = new SmsFilterDecorator(commonFiler); // 문자 알림 데이터 설정 NotificationRequest request = new NotificationRequest(\"NORMAL\", \"010-1111-2222\", \"Hello!\"); // SmsService 생성 SmsService service = new SmsService(smsSendingStrategy, smsFilter); service.sendSms(request); } 문자 발송 시작 A 외부 서비스 사용: [010-1111-2222]에게 'Hello!' 내용 문자 보내기 문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms 2. 회원 상태가 NORMAL 이 아니어서, 문자 발송을 하지 않는 경우 @Test void fail_sending_sms_when_invalid_member_status() { SmsSendingStrategy smsSendingStrategy = new SmsSendingStrategyA(); // 필터 설정 NotificationFilter commonFiler = new CommonFilter(); NotificationFilter smsFilter = new SmsFilterDecorator(commonFiler); // 문자 알림 데이터 설정 NotificationRequest request = new NotificationRequest(\"INVALID\", \"010-1111-2222\", \"Hello!\"); // SmsService 생성 SmsService service = new SmsService(smsSendingStrategy, smsFilter); service.sendSms(request); } 문자 발송 시작 문자를 발송할 수 없는 상태입니다. 3. 휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우 @Test void fail_sending_sms_when_invalid_cellphone_number() { SmsSendingStrategy smsSendingStrategy = new SmsSendingStrategyA(); // 필터 설정 NotificationFilter commonFiler = new CommonFilter(); NotificationFilter smsFilter = new SmsFilterDecorator(commonFiler); // 문자 알림 데이터 설정 NotificationRequest request = new NotificationRequest(\"NORMAL\", \"02-1111-2222\", \"Hello!\"); // SmsService 생성 SmsService service = new SmsService(smsSendingStrategy, smsFilter); service.sendSms(request); } 문자 발송 시작 문자를 발송할 수 없는 상태입니다. 실제 운영 환경이라면, 알림을 보내지 못하는 경우에 로그나 예외를 던져서 정확히 어떤 이유로 필터에서 걸러졌는지 명시해야 한다.\n정리 이 글에서는 디자인 패턴 중 동일하게 ‘프록시(proxy)’ 개념을 사용하는 두 패턴인 프록시 패턴과 데코레이터 패턴을 살펴보았다. 처음에 단순히 이 두 패턴을 따로 보았을 때, 특히 데코레이터 패턴을 이해하기가 쉽지 않았다. 그런데 김영한님의 인프런 강의 중 ‘스프링 핵심 원리 - 고급편’에서 프록시에 대해 심도있게 배울 수 있는데, 여기서 두 패턴에 대해서 깔끔하게 정리해주셨다. 프록시에 대해 자세히 코드에 어떻게 적용되는지 알고 싶고, 스프링 AOP의 원리에 대해서 알고 싶다면 이 강의를 강력 추천한다.\n앞서 말한 강의에서도 자세히 나오지만, 프록시를 직접 구현하는 일은 비용이 적지 않은 작업이다. 그리고 단순 반복이 많을 수도 있다. 이를 해결하고자 나온 개념이 ‘동적 프록시 기술’이다. 개발자가 프록시 객체를 코드로 구현하여 정적인 시점(컴파일 시점)에서 생성하는 것이 아닌, 개발자는 설정과 필요한 로직만 구현하고 런타임 시점에 프록시 객체를 자동으로 생성해주는 것이 동적 프록시 기술이다. 그리고 더 나아가 이를 사용하기 편하도록 추상화한 것이 Spring AOP 기술이다. 이에 대해서는 다음 글에서 좀 더 자세히 살펴볼 예정이다.\n참고자료 인프런 강의 - [스프링 핵심 원리 - 고급편] GoF의 디자인 패턴 ","wordCount":"1412","inLanguage":"en","datePublished":"2022-08-25T09:12:33+09:00","dateModified":"2022-08-25T09:12:33+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>[디자인 패턴] 프록시 패턴/데코레이터 패턴</h1><div class=post-meta><span title='2022-08-25 09:12:33 +0900 KST'>August 25, 2022</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ed%94%84%eb%a1%9d%ec%8b%9c-%ed%8c%a8%ed%84%b4-proxy-pattern aria-label="프록시 패턴 (Proxy Pattern)">프록시 패턴 (Proxy Pattern)</a></li><li><a href=#%eb%8d%b0%ec%bd%94%eb%a0%88%ec%9d%b4%ed%84%b0-%ed%8c%a8%ed%84%b4-decorator-pattern aria-label="데코레이터 패턴 (Decorator Pattern)">데코레이터 패턴 (Decorator Pattern)</a><ul><li><a href=#1-%ec%a0%95%ec%83%81%ec%a0%81%ec%9c%bc%eb%a1%9c-%eb%ac%b8%ec%9e%90-%ec%95%8c%eb%a6%bc%ec%9d%84-%eb%b0%9c%ec%86%a1%ed%95%98%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="1. 정상적으로 문자 알림을 발송하는 경우">1. 정상적으로 문자 알림을 발송하는 경우</a></li><li><a href=#2-%ed%9a%8c%ec%9b%90-%ec%83%81%ed%83%9c%ea%b0%80-normal-%ec%9d%b4-%ec%95%84%eb%8b%88%ec%96%b4%ec%84%9c-%eb%ac%b8%ec%9e%90-%eb%b0%9c%ec%86%a1%ec%9d%84-%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="2. 회원 상태가 NORMAL 이 아니어서, 문자 발송을 하지 않는 경우">2. 회원 상태가 <code>NORMAL</code> 이 아니어서, 문자 발송을 하지 않는 경우</a></li><li><a href=#3-%ed%9c%b4%eb%8c%80%ed%8f%b0-%eb%b2%88%ed%98%b8%ea%b0%80-%ec%a0%95%ec%83%81%ec%a0%81%ec%9d%b4%ec%a7%80-%ec%95%8a%ec%95%84%ec%84%9c-%eb%ac%b8%ec%9e%90-%eb%b0%9c%ec%86%a1%ec%9d%84-%ed%95%98%ec%a7%80-%ec%95%8a%eb%8a%94-%ea%b2%bd%ec%9a%b0 aria-label="3. 휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우">3. 휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우</a></li></ul></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li><li><a href=#%ec%b0%b8%ea%b3%a0%ec%9e%90%eb%a3%8c aria-label=참고자료>참고자료</a></li></ul></div></details></div><div class=post-content><p>이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.</p><p>프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.</p><ul><li>접근 제어<ul><li>권한에 따른 접근 차단</li><li>캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할)</li><li>지연 로딩</li></ul></li><li>부가 기능 추가<ul><li>값 변경</li><li>로깅</li><li>필터링</li><li>…</li></ul></li></ul><p>프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다. 이 의도는 <strong>프록시의 기능에 따라</strong> 나누고 있다.</p><ul><li>프록시 패턴 → 접근 제어</li><li>데코레이터 패턴 → 부가 기능 추가</li></ul><p>두 패턴 모두 프록시를 사용하므로, 사실 구현 방법은 동일하다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229323729-7145a7a0-2df7-4d10-abcb-2eaaa889fc63.png alt=proxy1></p><p>클라이언트는 원래 RealSubject를 사용해야 하지만, 접근 제어 또는 부가 기능을 위해 프록시를 추가하려고 한다. 클라이언트의 코드 변경없이 RealSubject 대신 프록시 객체를 사용하려면, 두 객체는 같은 타입으로 추상화되어야 한다. 따라서, 프록시를 사용하는 클래스 의존 관계는 위처럼 같은 타입의 인터페이스를 추상화하여 사용하게 된다. 이를 런타임 객체 의존 관계를 보면 프록시의 관계가 좀 더 명확하게 보일 것이다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229323760-b8640574-8695-4c72-ad90-f7abb49a29e9.png alt=proxy2></p><p>클라이언트가 런타임에서 실제로 사용하는 객체는 프록시 객체이고, 프록시 객체 내에서 접근 제어 또는 부가 기능을 수행한 후, 프록시가 실제 객체인 RealSubject 기능을 수행하게 된다.</p><p>지금까지 프록시에 대해서 알아보았고, 이제 예제를 통해 프록시 패턴과 데코레이터 패턴이 어떻게 사용되는지 살펴보자.</p><blockquote><p>전체 코드는 이 <a href=https://github.com/parker1609/my-articles/tree/main/Java/design-pattern>링크</a>에서 볼 수 있습니다.</p></blockquote><h1 id=프록시-패턴-proxy-pattern>프록시 패턴 (Proxy Pattern)<a hidden class=anchor aria-hidden=true href=#프록시-패턴-proxy-pattern>#</a></h1><p>프록시 패턴의 대표적인 예는 캐시가 있다. 캐시는 이미 데이터가 있으면, 기존의 데이터를 사용하고 없으면 새로 만든다. 코드 구조는 위에서 살펴본 Subject 인터페이스를 기반으로 한 모습과 동일하다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>Subject</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=nf>operation</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li><code>operation()</code> 메서드를 호출하면, 반환값으로 문자열 데이터를 받는다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>RealSubject</span> <span class=kd>implements</span> <span class=n>Subject</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>operation</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;RealSubject 호출&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;data&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li><code>RealSubject</code> 클래스는 <code>Subject</code> 인터페이스를 구현하고, 데이터를 실제로 만드는 역할을 한다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CacheProxySubject</span> <span class=kd>implements</span> <span class=n>Subject</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>Subject</span> <span class=n>target</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>cacheValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>CacheProxySubject</span><span class=o>(</span><span class=n>Subject</span> <span class=n>target</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>target</span> <span class=o>=</span> <span class=n>target</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=n>String</span> <span class=nf>operation</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;캐시 프록시 호출&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(</span><span class=n>cacheValue</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;캐시 값이 비어있으므로, 새로 생성&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=n>cacheValue</span> <span class=o>=</span> <span class=n>target</span><span class=o>.</span><span class=na>operation</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>cacheValue</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li><code>CacheProxySubject</code> 클래스도 역시 <code>Subject</code> 인터페이스를 구현하지만, 캐시 기능을 하는 프록시이다.</li><li>필드로 가지고 있는 <code>cacheValue</code> 문자열이 비어있으면, 실제 <code>RealSubject</code> 를 호출하여 데이터를 만든다.</li><li><code>cacheValue</code> 가 비어있지 않으면, 현재 가지고 있는 것을 그대로 반환한다.</li></ul><p>캐시 역할을 하는 프록시 패턴의 구현체는 모두 완성하였다. 이를 호출하는 클라이언트를 테스트 코드로 작성해보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>use_proxy_pattern</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Subject</span> <span class=n>realSubject</span> <span class=o>=</span> <span class=k>new</span> <span class=n>RealSubject</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>Subject</span> <span class=n>cacheProxy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CacheProxySubject</span><span class=o>(</span><span class=n>realSubject</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 처음 프록시 호출로 RealSubject를 호출하여 실제 데이터를 가져온다.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;----- 클라이언트에서 첫 번째 호출 -----&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cacheProxy</span><span class=o>.</span><span class=na>operation</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 두번째 호출부터는 RealSubject를 호출하지 않고, 캐시값을 사용한다.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;----- 클라이언트에서 두 번째 호출 -----&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cacheProxy</span><span class=o>.</span><span class=na>operation</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><pre tabindex=0><code>----- 클라이언트에서 첫 번째 호출 -----
캐시 프록시 호출
캐시 값이 비어있으므로, 새로 생성
RealSubject 호출
----- 클라이언트에서 두 번째 호출 -----
캐시 프록시 호출
</code></pre><p>결과를 보면, 처음 호출할 때는 캐시 프록시에 데이터가 없으므로 실제 <code>Subject</code> 구현체를 호출하여 데이터를 생성한다. 하지만 두 번째 호출부터는 실제 <code>Subject</code> 구현체를 전혀 사용하지 않고, 가지고 있는 데이터를 캐싱해서 반환하고 있다.</p><h1 id=데코레이터-패턴-decorator-pattern>데코레이터 패턴 (Decorator Pattern)<a hidden class=anchor aria-hidden=true href=#데코레이터-패턴-decorator-pattern>#</a></h1><p>데코레이터 패턴은 기능 추가를 실제 로직 변경없이, 프록시 형태로 독립된 곳에서 수행을 할 수 있다보니 활용도가 매우 높다. 이 글의 예제에서는 이전에 살펴보았던 <a href=https://velog.io/@codemcd/%EB%94%94%EC%9E%90%EC%9D%B8-%ED%8C%A8%ED%84%B4-%ED%85%9C%ED%94%8C%EB%A6%BF-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%8C%A8%ED%84%B4%EC%A0%84%EB%9E%B5-%ED%8C%A8%ED%84%B4%ED%85%9C%ED%94%8C%EB%A6%BF-%EC%BD%9C%EB%B0%B1-%ED%8C%A8%ED%84%B4>디자인 패턴 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴 글</a>에서 사용한 예제에서 기능을 추가해보자.</p><p>이전 예제에서 문자 알림을 전송하기 위해 <code>SmsService</code> 클래스의 <code>sendSms()</code> 메서드가 전체 전송 기능을 담당하고 있었다. (전략 패턴 예제 기준)</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>위 메서드 코드에서 실제로 문자 알림을 전송하는 부분은 <code>smsSendingStrategy.execute()</code> 메서드이다. 이 메서드를 호출하기 전에 알림을 실제로 보낼 수 있는 상태인지를 체크해야 하는 요구사항이 발생했다고 가정해보자.</p><ul><li>문자를 포함한 모든 알림은 회원 상태가 <code>NORMAL</code> 인 경우에만 전송한다.</li><li>문자 알림 전송은 유선 번호인 경우에는 제외한다.</li></ul><p>첫 번째 요구사항은 문자 외에도 이메일이나 앱푸시와 같은 모든 알림 수단에 공통적으로 체크해야 하는 사항이고, 두 번째 요구사항은 문자 알림에 특화된 체크사항이다. 이러한 상태 체크는 추가되거나 변경되는 일이 빈번하고, 알림 수단마다 공통적으로 필요한 것도 있다. 이러한 요구사항을 유연하게 대처하려면 어떻게 해야할까?</p><p>여기서는 데코레이터 패턴을 사용하여 이러한 요구사항을 유연하게 대처해보자.</p><p>데코레이터 패턴도 이 글 처음 프록시에 대해 살펴보았던 것처럼 클래스 구조는 동일하다. 위 요구사항을 바탕으로 다시 클래스 구조를 그려보자.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229323774-cf49eaa3-c81f-473f-b05b-b122ad2c3645.png alt=decorator-pattern></p><ul><li><code>NotificationFilter</code> : 전송할 수 있는지 체크하는 역할의 이름을 필터라고 두고, 알림을 전송할 수 있는지 검사하는 필터 인터페이스이다.</li><li><code>CommonFilter</code>: 모든 알림 수단에서 공통적으로 검사하는 필터로, 디폴트 필터 역할을 한다.<ul><li>회원 상태가 <code>NORMAL</code> 인지 검사</li></ul></li><li><code>SmsFilterDecorator</code>: 문자 알림에만 필요한 체크사항을 검사하는 필터 역할을 한다.<ul><li>휴대폰 번호가 정확한지 검사</li></ul></li></ul><p>위를 코드로 구현해보자. 먼저, 문자 전송을 담당하는 <code>SmsService</code> 클래스 전체 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SmsService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>NotificationFilter</span> <span class=n>notificationFilter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>SmsService</span><span class=o>(</span><span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span><span class=o>,</span> <span class=n>NotificationFilter</span> <span class=n>notificationFilter</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>smsSendingStrategy</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>notificationFilter</span> <span class=o>=</span> <span class=n>notificationFilter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>NotificationRequest</span> <span class=n>request</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span><span class=n>notificationFilter</span><span class=o>.</span><span class=na>canSend</span><span class=o>(</span><span class=n>request</span><span class=o>))</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자를 발송할 수 없는 상태입니다.&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>request</span><span class=o>.</span><span class=na>getCellphoneNumber</span><span class=o>(),</span> <span class=n>request</span><span class=o>.</span><span class=na>getSmsContents</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li>데코레이터 패턴을 적용한 알림 필터(<code>NotificationFilter</code>)가 필드로 추가되었다.</li><li>회원 상태 검사를 위한 데이터를 추가해야하는데, 이를 원래 알림에 필요한 데이터와 함께 <code>NotificationRequest</code> 클래스로 추출하였다. (아래 코드 참고)</li><li>필터가 적용되는 시점은 실제 전송하기 전에 검사를 한다.</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@AllArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=nd>@NoArgsConstructor</span>
</span></span><span class=line><span class=cl><span class=nd>@Getter</span>
</span></span><span class=line><span class=cl><span class=nd>@ToString</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>NotificationRequest</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>memberStatus</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li>회원 상태를 담고 있는 <code>membserStatus</code> 필드가 추가되었다. (사실, 문자열보다는 enum으로 관리하는 것이 훨씬 유연하게 상태를 관리할 수 있다.)</li></ul><p>데코레이터 패턴의 핵심인 알림 필터 코드는 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>NotificationFilter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>canSend</span><span class=o>(</span><span class=n>NotificationRequest</span> <span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>CommonFilter</span> <span class=kd>implements</span> <span class=n>NotificationFilter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>canSend</span><span class=o>(</span><span class=n>NotificationRequest</span> <span class=n>request</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=s>&#34;NORMAL&#34;</span><span class=o>.</span><span class=na>equals</span><span class=o>(</span><span class=n>request</span><span class=o>.</span><span class=na>getMemberStatus</span><span class=o>());</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SmsFilterDecorator</span> <span class=kd>implements</span> <span class=n>NotificationFilter</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>static</span> <span class=kd>final</span> <span class=n>Pattern</span> <span class=n>CELLPHONE_NUMBER_PATTERN</span> <span class=o>=</span> <span class=n>Pattern</span><span class=o>.</span><span class=na>compile</span><span class=o>(</span><span class=s>&#34;^01(?:0|1|[6-9])-(?:\\d{3}|\\d{4})-\\d{4}$&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>NotificationFilter</span> <span class=n>notificationFilter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>SmsFilterDecorator</span><span class=o>(</span><span class=n>NotificationFilter</span> <span class=n>notificationFilter</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>notificationFilter</span> <span class=o>=</span> <span class=n>notificationFilter</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>canSend</span><span class=o>(</span><span class=n>NotificationRequest</span> <span class=n>request</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>notificationFilter</span><span class=o>.</span><span class=na>canSend</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=o>(!</span><span class=n>result</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>false</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>Matcher</span> <span class=n>matcher</span> <span class=o>=</span> <span class=n>CELLPHONE_NUMBER_PATTERN</span><span class=o>.</span><span class=na>matcher</span><span class=o>(</span><span class=n>request</span><span class=o>.</span><span class=na>getCellphoneNumber</span><span class=o>());</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>matcher</span><span class=o>.</span><span class=na>find</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li>기존 공통 알림 필터 기능에 문자 알림을 위한 필터 기능이 추가되었다. (공통 알림 필터가 아닌 이전에 추가된 데코레이터 필터 기능으로도 볼 수 있다.)</li></ul><p>마지막으로, 이를 사용하는 클라이언트 코드를 살펴보자. 총 3가지 경우를 살펴보는 것이 데코레이터 패턴이 정상적으로 적용되었는지 확인할 수 있을 것이다.</p><ol><li>정상적으로 문자 알림을 발송하는 경우</li><li>회원 상태가 <code>NORMAL</code> 이 아니어서, 문자 발송을 하지 않는 경우</li><li>휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우</li></ol><h2 id=1-정상적으로-문자-알림을-발송하는-경우>1. 정상적으로 문자 알림을 발송하는 경우<a hidden class=anchor aria-hidden=true href=#1-정상적으로-문자-알림을-발송하는-경우>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>success_sending_sms</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsSendingStrategyA</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 필터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationFilter</span> <span class=n>commonFiler</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CommonFilter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>NotificationFilter</span> <span class=n>smsFilter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsFilterDecorator</span><span class=o>(</span><span class=n>commonFiler</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 문자 알림 데이터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NotificationRequest</span><span class=o>(</span><span class=s>&#34;NORMAL&#34;</span><span class=o>,</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>,</span> <span class=s>&#34;Hello!&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SmsService 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>(</span><span class=n>smsSendingStrategy</span><span class=o>,</span> <span class=n>smsFilter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><pre tabindex=0><code>문자 발송 시작
A 외부 서비스 사용: [010-1111-2222]에게 &#39;Hello!&#39; 내용 문자 보내기
문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms
</code></pre><h2 id=2-회원-상태가-normal-이-아니어서-문자-발송을-하지-않는-경우>2. 회원 상태가 <code>NORMAL</code> 이 아니어서, 문자 발송을 하지 않는 경우<a hidden class=anchor aria-hidden=true href=#2-회원-상태가-normal-이-아니어서-문자-발송을-하지-않는-경우>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fail_sending_sms_when_invalid_member_status</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsSendingStrategyA</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 필터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationFilter</span> <span class=n>commonFiler</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CommonFilter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>NotificationFilter</span> <span class=n>smsFilter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsFilterDecorator</span><span class=o>(</span><span class=n>commonFiler</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 문자 알림 데이터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NotificationRequest</span><span class=o>(</span><span class=s>&#34;INVALID&#34;</span><span class=o>,</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>,</span> <span class=s>&#34;Hello!&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SmsService 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>(</span><span class=n>smsSendingStrategy</span><span class=o>,</span> <span class=n>smsFilter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><pre tabindex=0><code>문자 발송 시작
문자를 발송할 수 없는 상태입니다.
</code></pre><h2 id=3-휴대폰-번호가-정상적이지-않아서-문자-발송을-하지-않는-경우>3. 휴대폰 번호가 정상적이지 않아서, 문자 발송을 하지 않는 경우<a hidden class=anchor aria-hidden=true href=#3-휴대폰-번호가-정상적이지-않아서-문자-발송을-하지-않는-경우>#</a></h2><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>fail_sending_sms_when_invalid_cellphone_number</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsSendingStrategyA</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=c1>// 필터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationFilter</span> <span class=n>commonFiler</span> <span class=o>=</span> <span class=k>new</span> <span class=n>CommonFilter</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>NotificationFilter</span> <span class=n>smsFilter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsFilterDecorator</span><span class=o>(</span><span class=n>commonFiler</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// 문자 알림 데이터 설정
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>NotificationRequest</span> <span class=n>request</span> <span class=o>=</span> <span class=k>new</span> <span class=n>NotificationRequest</span><span class=o>(</span><span class=s>&#34;NORMAL&#34;</span><span class=o>,</span> <span class=s>&#34;02-1111-2222&#34;</span><span class=o>,</span> <span class=s>&#34;Hello!&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// SmsService 생성
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>(</span><span class=n>smsSendingStrategy</span><span class=o>,</span> <span class=n>smsFilter</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>request</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><pre tabindex=0><code>문자 발송 시작
문자를 발송할 수 없는 상태입니다.
</code></pre><p>실제 운영 환경이라면, 알림을 보내지 못하는 경우에 로그나 예외를 던져서 정확히 어떤 이유로 필터에서 걸러졌는지 명시해야 한다.</p><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><p>이 글에서는 디자인 패턴 중 동일하게 ‘프록시(proxy)’ 개념을 사용하는 두 패턴인 프록시 패턴과 데코레이터 패턴을 살펴보았다. 처음에 단순히 이 두 패턴을 따로 보았을 때, 특히 데코레이터 패턴을 이해하기가 쉽지 않았다. 그런데 김영한님의 인프런 강의 중 ‘스프링 핵심 원리 - 고급편’에서 프록시에 대해 심도있게 배울 수 있는데, 여기서 두 패턴에 대해서 깔끔하게 정리해주셨다. 프록시에 대해 자세히 코드에 어떻게 적용되는지 알고 싶고, 스프링 AOP의 원리에 대해서 알고 싶다면 이 강의를 강력 추천한다.</p><p>앞서 말한 강의에서도 자세히 나오지만, 프록시를 직접 구현하는 일은 비용이 적지 않은 작업이다. 그리고 단순 반복이 많을 수도 있다. 이를 해결하고자 나온 개념이 ‘동적 프록시 기술&rsquo;이다. 개발자가 프록시 객체를 코드로 구현하여 정적인 시점(컴파일 시점)에서 생성하는 것이 아닌, 개발자는 설정과 필요한 로직만 구현하고 런타임 시점에 프록시 객체를 자동으로 생성해주는 것이 동적 프록시 기술이다. 그리고 더 나아가 이를 사용하기 편하도록 추상화한 것이 Spring AOP 기술이다. 이에 대해서는 다음 글에서 좀 더 자세히 살펴볼 예정이다.</p><h1 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h1><ul><li><a href=https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8#>인프런 강의 - [스프링 핵심 원리 - 고급편]</a></li><li><a href=http://www.yes24.com/Product/Goods/17525598>GoF의 디자인 패턴</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/design-pattern/>Design Pattern</a></li><li><a href=https://parker1609.github.io/tags/proxy-pattern/>Proxy Pattern</a></li><li><a href=https://parker1609.github.io/tags/decorator-pattern/>Decorator Pattern</a></li><li><a href=https://parker1609.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=prev href=https://parker1609.github.io/post/dynamic-proxy-with-spring/><span class=title>« Prev</span><br><span>동적 프록시(Dynamic Proxy) with Spring Framework</span></a>
<a class=next href=https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/><span class=title>Next »</span><br><span>[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>