<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>TDD, 클린 코드 with Kotlin 7기 후기 | Parker Blog</title><meta name=keywords content="NextStep,TDD,CleanCode,Kotlin,Review"><meta name=description content="Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)
코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U+6hYRq/Ez/nm5vg=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="TDD, 클린 코드 with Kotlin 7기 후기"><meta property="og:description" content="Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)
코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2024-01-28T18:34:34+09:00"><meta property="article:modified_time" content="2024-01-28T18:34:34+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="TDD, 클린 코드 with Kotlin 7기 후기"><meta name=twitter:description content="Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)
코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"TDD, 클린 코드 with Kotlin 7기 후기","item":"https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"TDD, 클린 코드 with Kotlin 7기 후기","name":"TDD, 클린 코드 with Kotlin 7기 후기","description":"Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)\n코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다.","keywords":["NextStep","TDD","CleanCode","Kotlin","Review"],"articleBody":" Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)\n코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다. 그러다 회사에서 이 교육에 지원할 사람을 모집하는 글을 보게 되었습니다. 예전부터 관심이 있던 강의였던지라 신청을 하였고, 운이 좋게도 선정이 되어 듣게 되었습니다.\n강의 기간은 2023년 10월 24일에서 2023년 12월 4일까지 약 두 달간 진행되었습니다. 미션은 총 4가지가 있었습니다.\n자동차 경주 게임 로또 게임 블랙잭 게임 지뢰 찾기 게임 미션은 1주에 하나씩 시작되었고, 미션 피드백과 코틀린에 대해서 강의도 한 주에 1개씩 진행하였다. 미션은 오픈 소스에 PR을 반영하는 방식과 거의 유사하게 진행되기 때문에 PR을 경험해볼 수 있다는 것도 큰 장점인 것 같다.\n미션은 기본적으로 1주에 하나씩 시작하였고, 주마다 코틀린에 대한 설명 및 미션 피드백에 대한 강의가 있었습니다. 미션을 진행은 단계별로 주어진 요구사항을 구현하고 PR을 보내 담당 리뷰어님에게 피드백을 받고 이를 반영하는 방식입니다. 가장 큰 도움이 되고 빠르게 배울 수 있었던 점이 바로 이러한 피드백 시스템이었습니다. 미션 자체도 게임이다보니 흥미가 있었고, 궁금한 부분에 대해서도 빠르게 피드백을 받을 수 있는 점이 정말 좋았습니다.\n매주 진행되는 제이슨님의 강의도 큰 도움이 되었습니다. 단순히 개념에 대해서 알려주는 딱딱한 방식이 아닌 미션이나 실제 현업에서 사용되는 코드를 기반으로 설명을 해주셨고, 채팅으로 궁금한 점에 대해서도 바로바로 답변을 주셨습니다. 전반적으로 매우 매우 만족스러운 강의였습니다.\n다행스럽게도 강의가 끝나는 주에 미션을 모두 완료하여 정말 뿌듯했습니다. 코틀린에 대해서도 빠르게 익숙해질 수 있어서 작은 프로젝트에 바로 도입을 해보아야겠다고 다짐했습니다.\n2월인 지금 아직 못지키고 있는게 아쉽지만… 올 해내에는 꼭 코틀린으로 개발하는 프로젝트 1개는 만들어볼 계획입니다!\n개인적인 미션 결과는 이 링크에서 확인해볼 수 있습니다.\n기억에 남는 미션 피드백 미션을 진행하면서 남기면 좋을 것 같은 피드백을 모아보았습니다. 사실 강의가 코틀린 언어 자체도 중요하지만 TDD(테스트), 클린 코드가 어떻게 보면 더 중요할 수도 있을 것 같습니다. 그러다보니 이에 대한 피드백이 더 기억에 남았던 것 같고, 클린 코드와 테스트를 코틀린에서 어떻게 잘 작성할까에 대한 피드백도 좋았었습니다.\nVO(Value Object)는 언제 사용해야할까? VO는 ‘값’을 객체로 분리하여 좀 더 유연한 코드를 만들 수 있다는 장점이 있습니다. 게다가 불변으로 유지해야하기 때문에 관리가 용이합니다. 이를 미션에 최대한 활용을 해보고 싶어졌지만, 어디에 그리고 얼만큼 이를 활용하는게 좋을지 감이 잡히지 않아 리뷰어님에게 질문을 드렸습니다.\n감사하게도 리뷰어님만의 기준을 말씀해주셨고, 이에 공감이 가기도 했고 저만의 기준이 필요하다고 느껴졌습니다. 미션은 학습을 위한 것이다보니 최대한 VO를 사용할 수 있는 곳은 사용해보고자 하였습니다. 그러다보면 자연스럽게 나만의 기준이 생기지 않을까도 기대해보았습니다. (답변 링크)\n객체를 나누는 기준 로또 게임은 자동차 경주 게임보다는 복잡한 요구사항을 가지고 있었습니다. 그러다보니 객체를 어떻게 나눠야할지가 큰 고민거리였습니다. 어떤 객체에 역할과 책임을 부여할지가 최대 관심사였던 기억이 납니다.\n이에 대해서도 리뷰어님에게 질문을 드렸고, 객체 지향에 대해서 다시 한 번 생각해보는 계기가 되었습니다. 객체 지향이 객체에 적절한 역할과 책임을 부여하고 이러한 객체들 사이의 관계가 중요하다고는 알고 있었습니다. 하지만 이를 어떻게 할까에 대한 고민은 깊게 하지 못했던 것 같습니다. 결국 객체지향은 깨끗한 코드를 유지하여 유지보수를 높이는 궁극적인 목표가 있습니다. 이를 위해서는 여러 개발자들이 보편적으로 떠올리는 생각들이 있을 것입니다. 이에 대해서 짚어주는 답변이었고, 크게 공감을 하였습니다. (답변 링크)\n코틀린이 제공하는 다양한 객체 선언 문법 코틀린에서는 객체를 선언하는 다양한 방법을 제공하고 있습니다. 특히, 값을 표현하기 위한 객체 선언을 data class와 value class 두 가지 방법으로 사용할 수 있다보니, 상황에 따라 적절히 사용하는 것이 필요하였습니다. 특히, value class에 대해서는 피드백을 통해 처음 알게 되기도 하여 이에 대해 찾아보고 비교를 해보았습니다.\n답변 링크\n답변 링크\n코틀린을 써보면서… 코틀린을 사용해보면서 느낀 장점은 생산성과 안정성이었습니다. 세미콜론과 같은 불필요한 문법을 제거하고 직관적인 이름으로 편리한 기능을 제공하는 API를 통해 생산성을 높일 수 있었습니다. 그리고 기본적으로 null을 허용하지 않고 불변으로 선언을 하기 때문에 실수를 줄여주었습니다. 미션을 통해서 이를 느낄 수 있었고 그에 대한 예제를 간단히 나열해보았습니다.\n세미콜론(;)이 필요없다. 이는 아래 예제에서 모두 살펴볼 수 있습니다.\n직관적이고 다양한 기능의 API 유효성 검사 require(namesOfRacingCar.isNotEmpty()) { \"자동차 이름은 1개 이상 존재해야 합니다.\" } require(numOfAttempts \u003e= 1) { \"시도 횟수는 1 이상이어야 합니다.\" } require(name.isNotBlank()) { \"자동차 이름은 공백일 수 없습니다.\" } require(name.length in 1..5) { \"자동차 이름은 1~5자만 가능합니다.\" } 반복문 repeat(numOfAttempts) { val movedRacingCars: MutableList\u003cRacingCar\u003e = mutableListOf() resultOfRacingCars.forEach { it.moveForward() movedRacingCars.add(it.copy()) } racingCarGameRound.add(RacingCarGameRound(round++, movedRacingCars)) } for (row in 0 until height) { for (col in 0 until width) { if (openedCoordinate.contains(Coordinate(row, col))) { print(\"${countingBoard.countAroundMine(row, col)} \") continue } print(\"C \") } println() } 컬렉션 컬렉션 내에서 편의를 위한 다양한 API를 제공해줍니다.\n// map(): 다른 객체로 변환해주는 메서드 val resultOfRacingCars = namesOfRacingCar.map { RacingCar(it, racingGameMoveRule) } // intersect(): 두 집합의 교집합을 구하는 메서드 val matchCount = lottoNumbers.values.intersect(winningLottoTicket.lottoNumbers.values.toSet()).size // shuffled(): 랜덤하게 컬렉션 내 요소를 섞어주는 메서드 LottoNumbers.lottoNumbersCandidates.shuffled().take(6) 문자열 처리가 편리하다. 문자열 내에서 변수를 사용할 수 있습니다.\noverride fun toString(): String { return \"RacingCar(name='$name', position=$position)\" } 문자열 내에서 표현식을 사용할 수 있습니다.\nprintln(\"${winners.racingCars.joinToString(\", \") { it.name }}가 최종 우승했습니다.\") 참고로, 위와 같은 기능을 코틀린에서는 문자열 템플릿(String Template) 기능이라고 합니다.\n불변으로 다루기가 쉽다. 불변 변수를 선언하는 val 이라는 키워드를 제공합니다. 거기다 기본적인 컬렉션 네이밍은 모두 불변으로 제공합니다.\n// val 키워드로 선언한 변수는 모두 불변 val names = ConsoleInput.inputNamesOfPlayer() val scoringRule = DefaultScoringRule() // 'mutable' 이라는 키워드를 포함하지 않는 기본 네이밍의 컬렉션은 모두 불변 val allPlayers = listOf(dealer, *participants.toTypedArray()) val cards: List\u003cCard\u003e get() = _cards.toList() 불변이 아닌 가변으로 변수를 선언하고 싶은 경우는 var 키워드로 변수를 선언해야 하며, 컬렉션인 경우는 mutable 이라는 키워드가 붙은 메서드 또는 객체를 사용해야합니다.\nvar input: String private val _cards: MutableList\u003cCard\u003e = mutableListOf() null 안전성을 쉽게 보장해준다. 코틀린에서 선언하는 모든 변수는 기본적으로 null을 허용하지 않습니다.\n단, null을 사용하기 위해서는 ? 키워드를 사용할 수 있습니다.\n널 가능 타입(Nullable Types): null을 허용하는 변수 선언 안전 호출 연산자(Safe Call Operator): null이 아닐 경우에만 호출 엘비스 연산자(Elvis Operator): null인 경우 반환할 값(또는 예외) 선언 (우항) // 널 가능 타입(Nullable Types) var name: String? = \"John\" name = null // 널 할당 가능 // 안전 호출 연산자(Safe Call Operator) println(name?.length) // 엘비스 연산자(Elvis Operator) val length = name?.length ?: 0 // null인 경우 0 반환 rows[Coordinate(row, col)] ?: throw IllegalArgumentException(\"존재하지 않는 좌표입니다.\") // null인 경우 예외 반환 물론, 장점만 존재하지는 않았습니다. 강의에서 진행한 미션은 순수한 코틀린으로도 충분하기 때문에 느끼지는 못했지만, 예전부터 자바에서 제공하던 라이브러리나 프레임워크에 대해서는 아직 사용이 불편한 점들이 있었습니다.\nJUnit에 비해 Kotest에서는 제공하지 않거나 사용하기 위해서 추가적인 설정 또는 우회가 필요하다거나 JPA, QueryDSL를 사용하기 위해서 복잡한 설정을 추가해야한다거나 … 또, 코틀린 DSL, 확장 함수, 연산자 오버로딩 등 다양한 구문을 제공하다보니 한 가지 기능을 구현하는데도 개발자마다 코드가 확연히 달라질 수 있습니다. 이는 여러 개발자가 같이 구현하기 위해서는 이를 위한 컨벤션이 필요할 것이고 이 또한 비용일 수 있습니다.\n개인적으로 코틀린을 사용해보면서 자바보다 확실히 생산성이 좋았습니다. 자바에서 불편했던 부분을 많이 개선했다는 느낌이 강하게 들었습니다. 코드량도 눈에 띄게 줄다보니 피로감도 낮았습니다. 단, 강의에서 진행한 미션에서는 스프링과 같은 복잡한 프레임워크나 라이브러리 없이 단순히 콘솔에서 동작하는 프로그램을 만드는 것이다보니 이러한 환경에서는 또 어떠할지는 모르겠습니다. 이미 경험한 분들의 말에 따르면 생각보다 불편하다는 것을 듣기는 하였습니다. (강의에서도 이 부분은 언급해주었고 실제로 필요한 설정들을 보니 사용 허들이 조금 높겠다고 느꼈습니다.)\n자바만을 주로 사용하다가 코틀린을 사용하니 재미도 있었고, 최근 서버에서 사용하는 언어 중 코틀린도 꾸준히 증가하고 있는 것을 보면 강의 이후에도 꾸준히 공부하고 사용해야겠다고 느꼈습니다.\n","wordCount":"1138","inLanguage":"en","datePublished":"2024-01-28T18:34:34+09:00","dateModified":"2024-01-28T18:34:34+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/ title=Home><span>Home</span></a></li><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>TDD, 클린 코드 with Kotlin 7기 후기</h1><div class=post-meta><span title='2024-01-28 18:34:34 +0900 KST'>January 28, 2024</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ea%b8%b0%ec%96%b5%ec%97%90-%eb%82%a8%eb%8a%94-%eb%af%b8%ec%85%98-%ed%94%bc%eb%93%9c%eb%b0%b1 aria-label="기억에 남는 미션 피드백">기억에 남는 미션 피드백</a><ul><li><a href=#vovalue-object%eb%8a%94-%ec%96%b8%ec%a0%9c-%ec%82%ac%ec%9a%a9%ed%95%b4%ec%95%bc%ed%95%a0%ea%b9%8c aria-label="VO(Value Object)는 언제 사용해야할까?">VO(Value Object)는 언제 사용해야할까?</a></li><li><a href=#%ea%b0%9d%ec%b2%b4%eb%a5%bc-%eb%82%98%eb%88%84%eb%8a%94-%ea%b8%b0%ec%a4%80 aria-label="객체를 나누는 기준">객체를 나누는 기준</a></li><li><a href=#%ec%bd%94%ed%8b%80%eb%a6%b0%ec%9d%b4-%ec%a0%9c%ea%b3%b5%ed%95%98%eb%8a%94-%eb%8b%a4%ec%96%91%ed%95%9c-%ea%b0%9d%ec%b2%b4-%ec%84%a0%ec%96%b8-%eb%ac%b8%eb%b2%95 aria-label="코틀린이 제공하는 다양한 객체 선언 문법">코틀린이 제공하는 다양한 객체 선언 문법</a></li></ul></li><li><a href=#%ec%bd%94%ed%8b%80%eb%a6%b0%ec%9d%84-%ec%8d%a8%eb%b3%b4%eb%a9%b4%ec%84%9c aria-label="코틀린을 써보면서…">코틀린을 써보면서…</a><ul><li><a href=#%ec%84%b8%eb%af%b8%ec%bd%9c%eb%a1%a0%ec%9d%b4-%ed%95%84%ec%9a%94%ec%97%86%eb%8b%a4 aria-label="세미콜론(;)이 필요없다.">세미콜론(;)이 필요없다.</a></li><li><a href=#%ec%a7%81%ea%b4%80%ec%a0%81%ec%9d%b4%ea%b3%a0-%eb%8b%a4%ec%96%91%ed%95%9c-%ea%b8%b0%eb%8a%a5%ec%9d%98-api aria-label="직관적이고 다양한 기능의 API">직관적이고 다양한 기능의 API</a><ul><li><a href=#%ec%9c%a0%ed%9a%a8%ec%84%b1-%ea%b2%80%ec%82%ac aria-label="유효성 검사">유효성 검사</a></li><li><a href=#%eb%b0%98%eb%b3%b5%eb%ac%b8 aria-label=반복문>반복문</a></li><li><a href=#%ec%bb%ac%eb%a0%89%ec%85%98 aria-label=컬렉션>컬렉션</a></li></ul></li><li><a href=#%eb%ac%b8%ec%9e%90%ec%97%b4-%ec%b2%98%eb%a6%ac%ea%b0%80-%ed%8e%b8%eb%a6%ac%ed%95%98%eb%8b%a4 aria-label="문자열 처리가 편리하다.">문자열 처리가 편리하다.</a></li><li><a href=#%eb%b6%88%eb%b3%80%ec%9c%bc%eb%a1%9c-%eb%8b%a4%eb%a3%a8%ea%b8%b0%ea%b0%80-%ec%89%bd%eb%8b%a4 aria-label="불변으로 다루기가 쉽다.">불변으로 다루기가 쉽다.</a></li><li><a href=#null-%ec%95%88%ec%a0%84%ec%84%b1%ec%9d%84-%ec%89%bd%ea%b2%8c-%eb%b3%b4%ec%9e%a5%ed%95%b4%ec%a4%80%eb%8b%a4 aria-label="null 안전성을 쉽게 보장해준다.">null 안전성을 쉽게 보장해준다.</a></li></ul></li></ul></div></details></div><div class=post-content><blockquote><p>Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: <a href=https://edu.nextstep.camp/c/Z9QeJlCi/>https://edu.nextstep.camp/c/Z9QeJlCi/</a>)</p></blockquote><p>코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다. 그러다 회사에서 이 교육에 지원할 사람을 모집하는 글을 보게 되었습니다. 예전부터 관심이 있던 강의였던지라 신청을 하였고, 운이 좋게도 선정이 되어 듣게 되었습니다.</p><p>강의 기간은 2023년 10월 24일에서 2023년 12월 4일까지 약 두 달간 진행되었습니다. 미션은 총 4가지가 있었습니다.</p><ol><li><a href=https://github.com/next-step/kotlin-racingcar>자동차 경주 게임</a></li><li><a href=https://github.com/next-step/kotlin-lotto>로또 게임</a></li><li><a href=https://github.com/next-step/kotlin-blackjack>블랙잭 게임</a></li><li><a href=https://github.com/next-step/kotlin-minesweeper>지뢰 찾기 게임</a></li></ol><p>미션은 1주에 하나씩 시작되었고, 미션 피드백과 코틀린에 대해서 강의도 한 주에 1개씩 진행하였다. 미션은 오픈 소스에 PR을 반영하는 방식과 거의 유사하게 진행되기 때문에 PR을 경험해볼 수 있다는 것도 큰 장점인 것 같다.</p><p>미션은 기본적으로 1주에 하나씩 시작하였고, 주마다 코틀린에 대한 설명 및 미션 피드백에 대한 강의가 있었습니다. 미션을 진행은 단계별로 주어진 요구사항을 구현하고 PR을 보내 담당 리뷰어님에게 피드백을 받고 이를 반영하는 방식입니다. 가장 큰 도움이 되고 빠르게 배울 수 있었던 점이 바로 이러한 피드백 시스템이었습니다. 미션 자체도 게임이다보니 흥미가 있었고, 궁금한 부분에 대해서도 빠르게 피드백을 받을 수 있는 점이 정말 좋았습니다.</p><p>매주 진행되는 제이슨님의 강의도 큰 도움이 되었습니다. 단순히 개념에 대해서 알려주는 딱딱한 방식이 아닌 미션이나 실제 현업에서 사용되는 코드를 기반으로 설명을 해주셨고, 채팅으로 궁금한 점에 대해서도 바로바로 답변을 주셨습니다. 전반적으로 매우 매우 만족스러운 강의였습니다.</p><p>다행스럽게도 강의가 끝나는 주에 미션을 모두 완료하여 정말 뿌듯했습니다. 코틀린에 대해서도 빠르게 익숙해질 수 있어서 작은 프로젝트에 바로 도입을 해보아야겠다고 다짐했습니다.</p><blockquote><p>2월인 지금 아직 못지키고 있는게 아쉽지만… 올 해내에는 꼭 코틀린으로 개발하는 프로젝트 1개는 만들어볼 계획입니다!</p><p>개인적인 미션 결과는 이 <a href="https://www.notion.so/457adb93680842c8ab5c6a815f7008c0?pvs=21">링크</a>에서 확인해볼 수 있습니다.</p></blockquote><h1 id=기억에-남는-미션-피드백>기억에 남는 미션 피드백<a hidden class=anchor aria-hidden=true href=#기억에-남는-미션-피드백>#</a></h1><p>미션을 진행하면서 남기면 좋을 것 같은 피드백을 모아보았습니다. 사실 강의가 코틀린 언어 자체도 중요하지만 TDD(테스트), 클린 코드가 어떻게 보면 더 중요할 수도 있을 것 같습니다. 그러다보니 이에 대한 피드백이 더 기억에 남았던 것 같고, 클린 코드와 테스트를 코틀린에서 어떻게 잘 작성할까에 대한 피드백도 좋았었습니다.</p><h2 id=vovalue-object는-언제-사용해야할까>VO(Value Object)는 언제 사용해야할까?<a hidden class=anchor aria-hidden=true href=#vovalue-object는-언제-사용해야할까>#</a></h2><p>VO는 ‘값’을 객체로 분리하여 좀 더 유연한 코드를 만들 수 있다는 장점이 있습니다. 게다가 불변으로 유지해야하기 때문에 관리가 용이합니다. 이를 미션에 최대한 활용을 해보고 싶어졌지만, 어디에 그리고 얼만큼 이를 활용하는게 좋을지 감이 잡히지 않아 리뷰어님에게 질문을 드렸습니다.</p><p><img loading=lazy src=https://github.com/parker1609/parker1609.github.io/assets/34755287/3835c5c6-1f1a-4a99-b1f1-5972ce5c86d7 alt=img1></p><p>감사하게도 리뷰어님만의 기준을 말씀해주셨고, 이에 공감이 가기도 했고 저만의 기준이 필요하다고 느껴졌습니다. 미션은 학습을 위한 것이다보니 최대한 VO를 사용할 수 있는 곳은 사용해보고자 하였습니다. 그러다보면 자연스럽게 나만의 기준이 생기지 않을까도 기대해보았습니다. (<a href=https://github.com/next-step/kotlin-racingcar/pull/1498#discussion_r1380417189>답변 링크</a>)</p><h2 id=객체를-나누는-기준>객체를 나누는 기준<a hidden class=anchor aria-hidden=true href=#객체를-나누는-기준>#</a></h2><p>로또 게임은 자동차 경주 게임보다는 복잡한 요구사항을 가지고 있었습니다. 그러다보니 객체를 어떻게 나눠야할지가 큰 고민거리였습니다. 어떤 객체에 역할과 책임을 부여할지가 최대 관심사였던 기억이 납니다.</p><p><img loading=lazy src=https://github.com/parker1609/parker1609.github.io/assets/34755287/754d155d-06ac-4f5d-a237-422736448ef7 alt=img2></p><p>이에 대해서도 리뷰어님에게 질문을 드렸고, 객체 지향에 대해서 다시 한 번 생각해보는 계기가 되었습니다. 객체 지향이 객체에 적절한 역할과 책임을 부여하고 이러한 객체들 사이의 관계가 중요하다고는 알고 있었습니다. 하지만 이를 어떻게 할까에 대한 고민은 깊게 하지 못했던 것 같습니다. 결국 객체지향은 깨끗한 코드를 유지하여 유지보수를 높이는 궁극적인 목표가 있습니다. 이를 위해서는 여러 개발자들이 보편적으로 떠올리는 생각들이 있을 것입니다. 이에 대해서 짚어주는 답변이었고, 크게 공감을 하였습니다. (<a href=https://github.com/next-step/kotlin-lotto/pull/902#pullrequestreview-1725875102>답변 링크</a>)</p><h2 id=코틀린이-제공하는-다양한-객체-선언-문법>코틀린이 제공하는 다양한 객체 선언 문법<a hidden class=anchor aria-hidden=true href=#코틀린이-제공하는-다양한-객체-선언-문법>#</a></h2><p>코틀린에서는 객체를 선언하는 다양한 방법을 제공하고 있습니다. 특히, 값을 표현하기 위한 객체 선언을 data class와 value class 두 가지 방법으로 사용할 수 있다보니, 상황에 따라 적절히 사용하는 것이 필요하였습니다. 특히, value class에 대해서는 피드백을 통해 처음 알게 되기도 하여 이에 대해 찾아보고 비교를 해보았습니다.</p><p><img loading=lazy src=https://github.com/parker1609/parker1609.github.io/assets/34755287/0a592f9d-7aaa-439c-9ed6-d5efcb53db16 alt=img3></p><p><a href=https://github.com/next-step/kotlin-lotto/pull/902#discussion_r1390081767>답변 링크</a></p><p><img loading=lazy src=https://github.com/parker1609/parker1609.github.io/assets/34755287/a346ff09-ed99-4e82-b86a-66226ea97b9e alt=img4></p><p><a href=https://github.com/next-step/kotlin-lotto/pull/902#discussion_r1390538322>답변 링크</a></p><h1 id=코틀린을-써보면서>코틀린을 써보면서…<a hidden class=anchor aria-hidden=true href=#코틀린을-써보면서>#</a></h1><p>코틀린을 사용해보면서 느낀 장점은 생산성과 안정성이었습니다. 세미콜론과 같은 불필요한 문법을 제거하고 직관적인 이름으로 편리한 기능을 제공하는 API를 통해 생산성을 높일 수 있었습니다. 그리고 기본적으로 null을 허용하지 않고 불변으로 선언을 하기 때문에 실수를 줄여주었습니다. 미션을 통해서 이를 느낄 수 있었고 그에 대한 예제를 간단히 나열해보았습니다.</p><h2 id=세미콜론이-필요없다>세미콜론(;)이 필요없다.<a hidden class=anchor aria-hidden=true href=#세미콜론이-필요없다>#</a></h2><p>이는 아래 예제에서 모두 살펴볼 수 있습니다.</p><h2 id=직관적이고-다양한-기능의-api>직관적이고 다양한 기능의 API<a hidden class=anchor aria-hidden=true href=#직관적이고-다양한-기능의-api>#</a></h2><h3 id=유효성-검사>유효성 검사<a hidden class=anchor aria-hidden=true href=#유효성-검사>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>require</span><span class=p>(</span><span class=n>namesOfRacingCar</span><span class=p>.</span><span class=n>isNotEmpty</span><span class=p>())</span> <span class=p>{</span> <span class=s2>&#34;자동차 이름은 1개 이상 존재해야 합니다.&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>require</span><span class=p>(</span><span class=n>numOfAttempts</span> <span class=o>&gt;=</span> <span class=m>1</span><span class=p>)</span> <span class=p>{</span> <span class=s2>&#34;시도 횟수는 1 이상이어야 합니다.&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>require</span><span class=p>(</span><span class=n>name</span><span class=p>.</span><span class=n>isNotBlank</span><span class=p>())</span> <span class=p>{</span> <span class=s2>&#34;자동차 이름은 공백일 수 없습니다.&#34;</span> <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>require</span><span class=p>(</span><span class=n>name</span><span class=p>.</span><span class=n>length</span> <span class=k>in</span> <span class=m>1.</span><span class=p>.</span><span class=m>5</span><span class=p>)</span> <span class=p>{</span> <span class=s2>&#34;자동차 이름은 1~5자만 가능합니다.&#34;</span> <span class=p>}</span>
</span></span></code></pre></div><h3 id=반복문>반복문<a hidden class=anchor aria-hidden=true href=#반복문>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>repeat</span><span class=p>(</span><span class=n>numOfAttempts</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=py>movedRacingCars</span><span class=p>:</span> <span class=n>MutableList</span><span class=p>&lt;</span><span class=n>RacingCar</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=n>resultOfRacingCars</span><span class=p>.</span><span class=n>forEach</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>it</span><span class=p>.</span><span class=n>moveForward</span><span class=p>()</span>
</span></span><span class=line><span class=cl>        <span class=n>movedRacingCars</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=k>it</span><span class=p>.</span><span class=n>copy</span><span class=p>())</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>racingCarGameRound</span><span class=p>.</span><span class=n>add</span><span class=p>(</span><span class=n>RacingCarGameRound</span><span class=p>(</span><span class=n>round</span><span class=o>++</span><span class=p>,</span> <span class=n>movedRacingCars</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=p>(</span><span class=n>row</span> <span class=k>in</span> <span class=m>0</span> <span class=n>until</span> <span class=n>height</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=p>(</span><span class=n>col</span> <span class=k>in</span> <span class=m>0</span> <span class=n>until</span> <span class=n>width</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=p>(</span><span class=n>openedCoordinate</span><span class=p>.</span><span class=n>contains</span><span class=p>(</span><span class=n>Coordinate</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>)))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            <span class=n>print</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>${countingBoard.countAroundMine(row, col)}</span><span class=s2> &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>            <span class=k>continue</span>
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>        <span class=n>print</span><span class=p>(</span><span class=s2>&#34;C &#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=n>println</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=컬렉션>컬렉션<a hidden class=anchor aria-hidden=true href=#컬렉션>#</a></h3><p>컬렉션 내에서 편의를 위한 다양한 API를 제공해줍니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// map(): 다른 객체로 변환해주는 메서드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>resultOfRacingCars</span> <span class=p>=</span> <span class=n>namesOfRacingCar</span><span class=p>.</span><span class=n>map</span> <span class=p>{</span> <span class=n>RacingCar</span><span class=p>(</span><span class=k>it</span><span class=p>,</span> <span class=n>racingGameMoveRule</span><span class=p>)</span> <span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// intersect(): 두 집합의 교집합을 구하는 메서드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>matchCount</span> <span class=p>=</span> <span class=n>lottoNumbers</span><span class=p>.</span><span class=n>values</span><span class=p>.</span><span class=n>intersect</span><span class=p>(</span><span class=n>winningLottoTicket</span><span class=p>.</span><span class=n>lottoNumbers</span><span class=p>.</span><span class=n>values</span><span class=p>.</span><span class=n>toSet</span><span class=p>()).</span><span class=n>size</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// shuffled(): 랜덤하게 컬렉션 내 요소를 섞어주는 메서드
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=nc>LottoNumbers</span><span class=p>.</span><span class=n>lottoNumbersCandidates</span><span class=p>.</span><span class=n>shuffled</span><span class=p>().</span><span class=n>take</span><span class=p>(</span><span class=m>6</span><span class=p>)</span>
</span></span></code></pre></div><h2 id=문자열-처리가-편리하다>문자열 처리가 편리하다.<a hidden class=anchor aria-hidden=true href=#문자열-처리가-편리하다>#</a></h2><p>문자열 내에서 변수를 사용할 수 있습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>override</span> <span class=k>fun</span> <span class=nf>toString</span><span class=p>():</span> <span class=n>String</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=s2>&#34;RacingCar(name=&#39;</span><span class=si>$name</span><span class=s2>&#39;, position=</span><span class=si>$position</span><span class=s2>)&#34;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>문자열 내에서 표현식을 사용할 수 있습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=n>println</span><span class=p>(</span><span class=s2>&#34;</span><span class=si>${winners.racingCars.joinToString(&#34;, &#34;) { it.name }</span><span class=s2>}가 최종 우승했습니다.&#34;</span><span class=p>)</span>
</span></span></code></pre></div><p>참고로, 위와 같은 기능을 코틀린에서는 문자열 템플릿(String Template) 기능이라고 합니다.</p><h2 id=불변으로-다루기가-쉽다>불변으로 다루기가 쉽다.<a hidden class=anchor aria-hidden=true href=#불변으로-다루기가-쉽다>#</a></h2><p>불변 변수를 선언하는 <code>val</code> 이라는 키워드를 제공합니다. 거기다 기본적인 컬렉션 네이밍은 모두 불변으로 제공합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// val 키워드로 선언한 변수는 모두 불변
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>names</span> <span class=p>=</span> <span class=nc>ConsoleInput</span><span class=p>.</span><span class=n>inputNamesOfPlayer</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>scoringRule</span> <span class=p>=</span> <span class=n>DefaultScoringRule</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// &#39;mutable&#39; 이라는 키워드를 포함하지 않는 기본 네이밍의 컬렉션은 모두 불변
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>allPlayers</span> <span class=p>=</span> <span class=n>listOf</span><span class=p>(</span><span class=n>dealer</span><span class=p>,</span> <span class=p>*</span><span class=n>participants</span><span class=p>.</span><span class=n>toTypedArray</span><span class=p>())</span>
</span></span><span class=line><span class=cl><span class=k>val</span> <span class=py>cards</span><span class=p>:</span> <span class=n>List</span><span class=p>&lt;</span><span class=n>Card</span><span class=p>&gt;</span> <span class=k>get</span><span class=p>()</span> <span class=p>=</span> <span class=n>_cards</span><span class=p>.</span><span class=n>toList</span><span class=p>()</span>
</span></span></code></pre></div><p>불변이 아닌 가변으로 변수를 선언하고 싶은 경우는 <code>var</code> 키워드로 변수를 선언해야 하며, 컬렉션인 경우는 <code>mutable</code> 이라는 키워드가 붙은 메서드 또는 객체를 사용해야합니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=k>var</span> <span class=py>input</span><span class=p>:</span> <span class=n>String</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>private</span> <span class=k>val</span> <span class=py>_cards</span><span class=p>:</span> <span class=n>MutableList</span><span class=p>&lt;</span><span class=n>Card</span><span class=p>&gt;</span> <span class=p>=</span> <span class=n>mutableListOf</span><span class=p>()</span>
</span></span></code></pre></div><h2 id=null-안전성을-쉽게-보장해준다>null 안전성을 쉽게 보장해준다.<a hidden class=anchor aria-hidden=true href=#null-안전성을-쉽게-보장해준다>#</a></h2><p>코틀린에서 선언하는 모든 변수는 기본적으로 null을 허용하지 않습니다.</p><p>단, null을 사용하기 위해서는 <code>?</code> 키워드를 사용할 수 있습니다.</p><ul><li>널 가능 타입(Nullable Types): null을 허용하는 변수 선언</li><li>안전 호출 연산자(Safe Call Operator): null이 아닐 경우에만 호출</li><li>엘비스 연산자(Elvis Operator): null인 경우 반환할 값(또는 예외) 선언 (우항)</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-kotlin data-lang=kotlin><span class=line><span class=cl><span class=c1>// 널 가능 타입(Nullable Types)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>var</span> <span class=py>name</span><span class=p>:</span> <span class=n>String</span><span class=p>?</span> <span class=p>=</span> <span class=s2>&#34;John&#34;</span>
</span></span><span class=line><span class=cl><span class=n>name</span> <span class=p>=</span> <span class=k>null</span> <span class=c1>// 널 할당 가능
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl><span class=c1>// 안전 호출 연산자(Safe Call Operator)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>println</span><span class=p>(</span><span class=n>name</span><span class=o>?.</span><span class=n>length</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 엘비스 연산자(Elvis Operator)
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>val</span> <span class=py>length</span> <span class=p>=</span> <span class=n>name</span><span class=o>?.</span><span class=n>length</span> <span class=o>?:</span> <span class=m>0</span>  <span class=c1>// null인 경우 0 반환
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>rows</span><span class=p>[</span><span class=n>Coordinate</span><span class=p>(</span><span class=n>row</span><span class=p>,</span> <span class=n>col</span><span class=p>)]</span> <span class=o>?:</span> <span class=k>throw</span> <span class=n>IllegalArgumentException</span><span class=p>(</span><span class=s2>&#34;존재하지 않는 좌표입니다.&#34;</span><span class=p>)</span>  <span class=c1>// null인 경우 예외 반환
</span></span></span></code></pre></div><p>물론, 장점만 존재하지는 않았습니다. 강의에서 진행한 미션은 순수한 코틀린으로도 충분하기 때문에 느끼지는 못했지만, 예전부터 자바에서 제공하던 라이브러리나 프레임워크에 대해서는 아직 사용이 불편한 점들이 있었습니다.</p><ul><li>JUnit에 비해 Kotest에서는 제공하지 않거나 사용하기 위해서 추가적인 설정 또는 우회가 필요하다거나</li><li>JPA, QueryDSL를 사용하기 위해서 복잡한 설정을 추가해야한다거나</li><li>…</li></ul><p>또, 코틀린 DSL, 확장 함수, 연산자 오버로딩 등 다양한 구문을 제공하다보니 한 가지 기능을 구현하는데도 개발자마다 코드가 확연히 달라질 수 있습니다. 이는 여러 개발자가 같이 구현하기 위해서는 이를 위한 컨벤션이 필요할 것이고 이 또한 비용일 수 있습니다.</p><p>개인적으로 코틀린을 사용해보면서 자바보다 확실히 생산성이 좋았습니다. 자바에서 불편했던 부분을 많이 개선했다는 느낌이 강하게 들었습니다. 코드량도 눈에 띄게 줄다보니 피로감도 낮았습니다. 단, 강의에서 진행한 미션에서는 스프링과 같은 복잡한 프레임워크나 라이브러리 없이 단순히 콘솔에서 동작하는 프로그램을 만드는 것이다보니 이러한 환경에서는 또 어떠할지는 모르겠습니다. 이미 경험한 분들의 말에 따르면 생각보다 불편하다는 것을 듣기는 하였습니다. (강의에서도 이 부분은 언급해주었고 실제로 필요한 설정들을 보니 사용 허들이 조금 높겠다고 느꼈습니다.)</p><p>자바만을 주로 사용하다가 코틀린을 사용하니 재미도 있었고, 최근 서버에서 사용하는 언어 중 코틀린도 꾸준히 증가하고 있는 것을 보면 강의 이후에도 꾸준히 공부하고 사용해야겠다고 느꼈습니다.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/nextstep/>NextStep</a></li><li><a href=https://parker1609.github.io/tags/tdd/>TDD</a></li><li><a href=https://parker1609.github.io/tags/cleancode/>CleanCode</a></li><li><a href=https://parker1609.github.io/tags/kotlin/>Kotlin</a></li><li><a href=https://parker1609.github.io/tags/review/>Review</a></li></ul><nav class=paginav><a class=next href=https://parker1609.github.io/post/ai/utilizing-chatgpt-part-1/><span class=title>Next »</span><br><span>ChatGPT 활용하기 - Part 1</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2024 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>