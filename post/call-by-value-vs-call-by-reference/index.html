<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Call by Value vs Call by Reference | Parker Blog</title><meta name=keywords content="Java,C++,Call By Value,Call By Reference"><meta name=description content="C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!
먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.
Call By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/call-by-value-vs-call-by-reference/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Call by Value vs Call by Reference"><meta property="og:description" content="C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!
먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.
Call By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/call-by-value-vs-call-by-reference/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-03-04T13:40:05+09:00"><meta property="article:modified_time" content="2020-03-04T13:40:05+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Call by Value vs Call by Reference"><meta name=twitter:description content="C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!
먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.
Call By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"Call by Value vs Call by Reference","item":"https://parker1609.github.io/post/call-by-value-vs-call-by-reference/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Call by Value vs Call by Reference","name":"Call by Value vs Call by Reference","description":"C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!\n먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.\nCall By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다.","keywords":["Java","C++","Call By Value","Call By Reference"],"articleBody":" C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!\n먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.\nCall By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다. 여기서 value란 무엇일까요?\nValue는 말그대로 값 그 자체입니다. 따라서 값을 담을 수 있는 모든 타입이 가능합니다. 정수형, 문자형, 문자열, 실수형 그리고 주소값까지 모두 값이 될 수 있습니다.\nValue에 대해 C++언어에서 예를 보겠습니다.\nint a = 10; char b = 'b'; float c = 1.5; int* d = \u0026a; Person* p = new Person(); 변수 a를 call by value로 하면 10이라는 값이 전달됩니다. p 변수를 call by value로 하면 p에 담긴 값 그대로 전달됩니다. 변수 p에는 어떤 값이 들어 있을까요? Person 객체를 선언한 주소값이 들어가겠죠? 그렇다면 이 주소값이 원본이며, 그대로 복사되어 전달됩니다.\n좀 더 자세한 예제를 보겠습니다.\nvoid CallByInteger(int argA) { cout \u003c\u003c \"Caller Integer: \"\u003c\u003c argA \u003c\u003c endl; argA = 20; cout \u003c\u003c \"Caller Integer After Changing: \"\u003c\u003c argA \u003c\u003c endl; } void CallByCharacter(char argB) { cout \u003c\u003c \"Caller Character: \" \u003c\u003c argB \u003c\u003c endl; argB = 'c'; cout \u003c\u003c \"Caller Character After Changing: \" \u003c\u003c argB \u003c\u003c endl; } void CallByFloat(float argC) { cout \u003c\u003c \"Caller Float: \" \u003c\u003c argC \u003c\u003c endl; argC = 10.5; cout \u003c\u003c \"Caller Float After Changing: \" \u003c\u003c argC \u003c\u003c endl; } void CallByAddress(int* argD) { cout \u003c\u003c \"Caller Address: \" \u003c\u003c argD \u003c\u003c endl; int temp = 30; argD = \u0026temp; cout \u003c\u003c \"Caller Address After Changing: \" \u003c\u003c argD \u003c\u003c endl; } int main() { int a = 10; cout \u003c\u003c \"Before Callee Integer: \" \u003c\u003c a \u003c\u003c endl; CallByInteger(a); cout \u003c\u003c \"After Callee Integer: \" \u003c\u003c a \u003c\u003c endl \u003c\u003c endl; char b = 'b'; cout \u003c\u003c \"Before Callee Character: \" \u003c\u003c b \u003c\u003c endl; CallByCharacter(b); cout \u003c\u003c \"After Callee Character: \" \u003c\u003c b \u003c\u003c endl \u003c\u003c endl; float c = 1.5; cout \u003c\u003c \"Before Callee Float: \" \u003c\u003c c \u003c\u003c endl; CallByFloat(c); cout \u003c\u003c \"After Callee Float: \" \u003c\u003c c \u003c\u003c endl \u003c\u003c endl; int* d = \u0026a; cout \u003c\u003c \"Before Callee Address: \" \u003c\u003c d \u003c\u003c endl; CallByAddress(d); cout \u003c\u003c \"After Callee Address: \" \u003c\u003c d \u003c\u003c endl; return 0; } Before Callee Integer: 10 Caller Integer: 10 Caller Integer After Changing: 20 After Callee Integer: 10 Before Callee Character: b Caller Character: b Caller Character After Changing: c After Callee Character: b Before Callee Float: 1.5 Caller Float: 1.5 Caller Float After Changing: 10.5 After Callee Float: 1.5 Before Callee Address: 0x7ffee074e9bc Caller Address: 0x7ffee074e9bc Caller Address After Changing: 0x7ffee074e944 After Callee Address: 0x7ffee074e9bc 위 예제는 main() 함수에서 int, char, float, int* 형의 값을 call by value로 각각의 함수의 매개변수로 전달하는 모습입니다.\nint* d = \u0026a; int*는 int 타입의 주소값을 저장하는 자료형입니다. \u0026는 그 뒤에 나오는 변수의 주소값을 가져오는 키워드입니다.\nCall by value의 가장 큰 특징은 원본에 영향을 미치지 않는다는 것입니다. 위 예제서도 볼 수 있듯이 caller에서 전달받은 매개변수의 값을 변경하여도, callee에서의 값은 변하지 않습니다. 이는 주소값을 전달하여도 같습니다. 마지막 예제를 보시면 callee에서 before, after 주소값이 같은 것을 볼 수 있습니다.\n매개변수는 전달받은 값을 바탕으로 새로운 지역변수를 만듭니다. 즉, 원본과는 전혀 다른 메모리 공간에 새로운 변수를 만든다는 의미입니다. 따라서 매개변수가 원본의 value를 가진다면 원본과는 전혀 다른 변수라고 볼 수 있습니다. 하지만 원본의 주소값(reference)을 가진다면 원본에 접근이 가능하게 됩니다. 이는 call by reference에서 설명하겠습니다.\n그렇다면 가장 헷갈렸던 주소값을 call by value로 전달하는 예제를 좀 더 살펴보겠습니다.\nclass Person { public: Person(string name, int age) : mName(name), mAge(age) {} void printInfo() { cout \u003c\u003c \"name: \" \u003c\u003c mName \u003c\u003c \", age: \" \u003c\u003c mAge \u003c\u003c endl; } private: string mName; int mAge; }; void ChangePersonCallByValue(Person *argP) { argP = new Person(\"Kim\", 30); } int main() { Person *p = new Person(\"Park\", 25); ChangePersonCallByValue(p); p-\u003eprintInfo(); delete p; return 0; } name: Park, age: 25 Person 클래스는 이름과 나이를 가지고 있습니다. main()문을 살펴보면 이름 “Park”, 나이 25살이라는 Person 객체를 생성했습니다. 이를 call by value로 ChangePersonCallByValue() 함수에 전달했습니다. 그 후 해당 매개변수에 새로운 Person 객체를 할당하였습니다.\n결과는 call by value이므로 원본에 영향을 미치지 못했습니다.\n여기서 잠깐 원본에 대해 알아보겠습니다. 제가 call by value와 call by reference를 구분짓는 중요한 부분은 원본에 대해 제가 생각했던 정의입니다. 위 Person 예제에서 변수 p의 원본은 무엇일까요? 대부분 내부의 name과 age 값이라고 생각합니다. 물론 그렇게 생각할 수 있지만, 원본을 내부의 데이터까지 포함하면 헷갈리기 시작합니다.\n원본은 첫 번째 예제에서 살펴본 것과 같이 변수 p 그 자체입니다. 변수 p에는 생성한 Person 객체의 주소값이 있습니다. 제가 정의한 원본은 이 주소값에 한정합니다. 왜냐하면 변수 p는 Person* 자료형이며, 이는 Person 객체의 주소값을 저장하는 역할입니다. 변수 p 입장에서는 내부 데이터와는 연관이 없을 수 있겠다고 생각했습니다.\n말씀드린 원본의 정의를 위와 같이 하면 call by value와 call by reference는 정확히 구분된다고 생각합니다. 원본을 내부 값까지 다 포함한다고 생각하면, 아래 예제처럼 주소값이 전달되는 경우 원본을 변경할 수 있으므로 call by reference라고도 볼 수 있어 기준이 흔들립니다.\nclass Person { public: Person(string name, int age) : mName(name), mAge(age) {} void changePerson(string name, int age) // 1) { mName = name; mAge = age; } void printInfo() { cout \u003c\u003c \"name: \" \u003c\u003c mName \u003c\u003c \", age: \" \u003c\u003c mAge \u003c\u003c endl; } private: string mName; int mAge; }; void ChangePersonCallByValue(Person *argP) { argP-\u003echangePerson(\"Kim\", 30); } int main() { Person *p = new Person(\"Park\", 25); ChangePersonCallByValue(p); p-\u003eprintInfo(); delete p; return 0; } name: Kim, age: 30 위 예제는 똑같이 call by value로 전달하였는데, 결과는 내부 값이 변경되었습니다. 하지만 아래 main() 함수로 변경하여 실제 원본 값을 비교해보면 원본은 변경된 것이 아닙니다.\nint main() { Person *p = new Person(\"Park\", 25); cout \u003c\u003c \"Before call by value: p = \" \u003c\u003c p \u003c\u003c endl; ChangePersonCallByValue(p); p-\u003eprintInfo(); cout \u003c\u003c \"After call by value: p = \" \u003c\u003c p \u003c\u003c endl; delete p; return 0; } Before call by value: p = 0x7f8a8c405830 name: Kim, age: 30 After call by value: p = 0x7f8a8c405830 현재까지는 객체만을 살펴봤지만, 배열도 같습니다. 배열 역시 이를 사용하는 변수는 가장 첫 번째를 가리키는 주소값이 저장되어있습니다. 그 외의 요소는 위에서 살펴본 객체 예제처럼 내부 값이라고 생각할 수 있습니다.\n정리하면, call by value는 원본을 변경할 수 없습니다. value가 주소값을 포함해서 어떤 자료형의 값이 와도 실제 원본은 변경할 수 없습니다.\nCall By Reference Call by reference는 원본의 주소값을 전달하므로, 원본을 변경할 수 있습니다. 왜냐하면 주소값을 통해 원본에 접근할 수 있기 때문입니다. 그런데 중요한 점이 한 가지 있습니다. 주소값을 저장할 수 있는 자료형을 제공해야 call by reference를 사용할 수 있습니다.\n원본의 주소값이라고 하면 원본이 할당되어 있는 메모리의 주소값을 말합니다. 따라서 원본의 값이 주소값인 것과 상관없이 어떤 종류의 값이라도 이에 할당되어 있는 메모리 주소가 있을 것입니다.\n원본의 주소값을 가질 수 있는 방법은 이를 저장할 수 있는 자료형이 존재한다는 의미와 동일합니다. 먼저 가장 대표적인 Swap() 예제를 살펴보겠습니다.\nvoid Swap(int *num1, int *num2) { int temp = *num1; *num1 = *num2; *num2 = temp; } int main() { int a = 10; int b = 20; cout \u003c\u003c \"Before Swap: \" \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c \", b = \" \u003c\u003c b \u003c\u003c endl; Swap(\u0026a, \u0026b); cout \u003c\u003c \"After Swap: \" \u003c\u003c \"a = \" \u003c\u003c a \u003c\u003c \", b = \" \u003c\u003c b \u003c\u003c endl; return 0; } Before Swap: a = 10, b = 20 After Swap: a = 20, b = 10 위 Swap() 함수는 int형 변수 두 개를 call by reference로 전달하여 서로 맞바꾸는 역할을 합니다. 결과를 보면 caller 함수 내부의 변경으로 callee 함수의 원본에 영향을 끼친 것을 알 수 있습니다.\n이가 가능한 것은 위 예제에서 사용한 C++언어가 제공하는 *, \u0026 키워드 때문입니다. 이 키워드에 대해서는 가장 첫번째 예제에서 설명했습니다. 짧게 요약하면 변수의 주소값을 추출하고, 이를 저장할 수 있는 키워드입니다.\n위 예제를 스택 메모리로 살펴보면 더 쉽게 이해할 수 있을 것입니다.\n아래 메모리 그림은 매우 단순화한 것입니다.\nSwap() 함수 실행 전 Swap() 함수 실행 후 위 그림의 주소값 2000부터 위로는 Swap() 함수의 메모리 공간입니다.\n이렇게 C/C++과 같이 변수의 주소를 추출하고, 저장할 수 있는 키워드를 제공하는 언어는 call by reference를 할 수 있습니다. 하지만 이를 할 수 없는 Java는 call by reference를 할 수 없습니다.\n그렇다면 C++에서 객체를 call by reference로 전달하는 예제를 살펴보겠습니다.\nclass Person { public: Person(string name, int age) : mName(name), mAge(age) {} void printInfo() { cout \u003c\u003c \"name: \" \u003c\u003c mName \u003c\u003c \", age: \" \u003c\u003c mAge \u003c\u003c endl; } private: string mName; int mAge; }; void ChangePersonCallByReference(Person **argP) { delete (*argP); (*argP) = new Person(\"Kim\", 30); } int main() { Person *p = new Person(\"Park\", 25); ChangePersonCallByReference(\u0026p); p-\u003eprintInfo(); delete p; return 0; } name: Kim, age: 30 위 예제는 call by value에서는 할 수 없었던 caller 함수 내부에서 원본에 새로운 Person 객체를 할당하는 모습입니다.\nPerson* 자료형의 주소를 저장하기 위해 *키워드를 사용하여 Person** 자료형을 사용하였고, 이 주소를 추출하기 위해 \u0026 키워드를 사용했습니다. 그렇다면 실제 주소값이 변경되는지 살펴보겠습니다.\nint main() { Person *p = new Person(\"Park\", 25); cout \u003c\u003c \"Before call by reference: p = \" \u003c\u003c p \u003c\u003c endl; ChangePersonCallByReference(\u0026p); p-\u003eprintInfo(); cout \u003c\u003c \"After call by reference: p = \" \u003c\u003c p \u003c\u003c endl; delete p; return 0; } Before call by reference: p = 0x7ff858c05830 name: Kim, age: 30 After call by reference: p = 0x7ff858c05850 After에서 원본 값이 변경된 것을 볼 수 있습니다.\n위 변수 p의 값이 같게 나오시는 분들은 ChangePersonCallByReference() 함수안의 delete (*argP);를 지우고 실행해보시길 바랍니다. 워낙 간단한 로직이다 보니 delete한 메모리에 바로 새로운 객체를 할당하여 같은 주소값이 되는 경우가 있었습니다.\n이 예제 역시 Swap() 함수 예제처럼 메모리를 살펴보면 좀 더 쉽게 이해할 수 있을 것입니다.\nChangePersonCallByReference() 함수 실행 전 ChangePersonCallByReference() 함수 실행 후 C++에서 new 키워드로 객체를 생성하면 Heap 메모리에 할당됩니다.\n정리 지금까지 살펴본 것을 정리해보겠습니다.\nCall By Value: 원본 값을 그대로 복사하여 전달하며, 원본에 영향을 미칠 수 없습니다. Call By Reference: 원본의 주소값을 복사하여 전달하며, 원본에 영향을 미칠 수 있습니다. 변수의 주소값을 추출 및 저장하는 기능을 언어 차원에서 제공해주어야 call by reference가 가능합니다. C/C++는 Call By Value, Call By Reference 둘 다 가능하지만, Java는 Call By Value로만 동작할 수 있습니다. C++로 call by reference를 사용하여 코딩하며 생각한 것이지만, call by reference를 사용하면 가독성이 안좋아진다고 생각합니다. 함수를 볼 때마다 매개변수로 전달받은 값이 원본에 영향을 주는지 주의깊게 살펴봐야합니다. 이러한 부분은 컨벤션을 정해놓고 코딩하는 것이 좋을 것 같습니다. (제가 알기로는 C++을 사용하는 회사의 컨벤션에 이와 관련된 것이 있는 것으로 알고 있습니다.)\n","wordCount":"1686","inLanguage":"en","datePublished":"2020-03-04T13:40:05+09:00","dateModified":"2020-03-04T13:40:05+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/call-by-value-vs-call-by-reference/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/ title=Home><span>Home</span></a></li><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>Call by Value vs Call by Reference</h1><div class=post-meta><span title='2020-03-04 13:40:05 +0900 KST'>March 4, 2020</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#call-by-value aria-label="Call By Value">Call By Value</a></li><li><a href=#call-by-reference aria-label="Call By Reference">Call By Reference</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li></ul></div></details></div><div class=post-content><blockquote><p>C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!</p></blockquote><p>먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.</p><h2 id=call-by-value>Call By Value<a hidden class=anchor aria-hidden=true href=#call-by-value>#</a></h2><p>Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다. 여기서 value란 무엇일까요?</p><p>Value는 말그대로 <strong>값</strong> 그 자체입니다. 따라서 값을 담을 수 있는 모든 타입이 가능합니다. 정수형, 문자형, 문자열, 실수형 그리고 <strong>주소값</strong>까지 모두 값이 될 수 있습니다.</p><p>Value에 대해 C++언어에서 예를 보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>char</span> <span class=n>b</span> <span class=o>=</span> <span class=sc>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=mf>1.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=kt>int</span><span class=o>*</span> <span class=n>d</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>Person</span><span class=o>*</span> <span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>();</span>
</span></span></code></pre></div><p>변수 <code>a</code>를 call by value로 하면 10이라는 값이 전달됩니다. <code>p</code> 변수를 call by value로 하면 <code>p</code>에 담긴 값 그대로 전달됩니다. 변수 <code>p</code>에는 어떤 값이 들어 있을까요? <code>Person</code> 객체를 선언한 주소값이 들어가겠죠? 그렇다면 이 주소값이 원본이며, 그대로 복사되어 전달됩니다.</p><p>좀 더 자세한 예제를 보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>CallByInteger</span><span class=p>(</span><span class=kt>int</span> <span class=n>argA</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Integer: &#34;</span><span class=o>&lt;&lt;</span> <span class=n>argA</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>argA</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Integer After Changing: &#34;</span><span class=o>&lt;&lt;</span> <span class=n>argA</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>CallByCharacter</span><span class=p>(</span><span class=kt>char</span> <span class=n>argB</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Character: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argB</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>argB</span> <span class=o>=</span> <span class=sc>&#39;c&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Character After Changing: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argB</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>CallByFloat</span><span class=p>(</span><span class=kt>float</span> <span class=n>argC</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Float: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argC</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>argC</span> <span class=o>=</span> <span class=mf>10.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Float After Changing: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argC</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>CallByAddress</span><span class=p>(</span><span class=kt>int</span><span class=o>*</span> <span class=n>argD</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Address: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argD</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=mi>30</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>argD</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Caller Address After Changing: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>argD</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before Callee Integer: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CallByInteger</span><span class=p>(</span><span class=n>a</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After Callee Integer: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>b</span> <span class=o>=</span> <span class=sc>&#39;b&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before Callee Character: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CallByCharacter</span><span class=p>(</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After Callee Character: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>c</span> <span class=o>=</span> <span class=mf>1.5</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before Callee Float: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CallByFloat</span><span class=p>(</span><span class=n>c</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After Callee Float: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>c</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>int</span><span class=o>*</span> <span class=n>d</span> <span class=o>=</span> <span class=o>&amp;</span><span class=n>a</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before Callee Address: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>CallByAddress</span><span class=p>(</span><span class=n>d</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After Callee Address: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>d</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>Before Callee Integer: 10
Caller Integer: 10
Caller Integer After Changing: 20
After Callee Integer: 10

Before Callee Character: b
Caller Character: b
Caller Character After Changing: c
After Callee Character: b

Before Callee Float: 1.5
Caller Float: 1.5
Caller Float After Changing: 10.5
After Callee Float: 1.5

Before Callee Address: 0x7ffee074e9bc
Caller Address: 0x7ffee074e9bc
Caller Address After Changing: 0x7ffee074e944
After Callee Address: 0x7ffee074e9bc
</code></pre><p>위 예제는 <code>main()</code> 함수에서 <code>int</code>, <code>char</code>, <code>float</code>, <code>int*</code> 형의 값을 call by value로 각각의 함수의 매개변수로 전달하는 모습입니다.</p><blockquote><p><code>int* d = &amp;a;</code>
<code>int*</code>는 int 타입의 주소값을 저장하는 자료형입니다.
<code>&</code>는 그 뒤에 나오는 변수의 주소값을 가져오는 키워드입니다.</p></blockquote><p><strong>Call by value의 가장 큰 특징은 원본에 영향을 미치지 않는다는 것입니다.</strong> 위 예제서도 볼 수 있듯이 caller에서 전달받은 매개변수의 값을 변경하여도, callee에서의 값은 변하지 않습니다. 이는 <strong>주소값을 전달하여도 같습니다.</strong> 마지막 예제를 보시면 callee에서 before, after 주소값이 같은 것을 볼 수 있습니다.</p><blockquote><p>매개변수는 전달받은 값을 바탕으로 새로운 지역변수를 만듭니다. 즉, 원본과는 전혀 다른 메모리 공간에 새로운 변수를 만든다는 의미입니다. 따라서 매개변수가 원본의 value를 가진다면 원본과는 전혀 다른 변수라고 볼 수 있습니다. 하지만 원본의 주소값(reference)을 가진다면 원본에 접근이 가능하게 됩니다. 이는 call by reference에서 설명하겠습니다.</p></blockquote><p>그렇다면 가장 헷갈렸던 주소값을 call by value로 전달하는 예제를 좀 더 살펴보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span> <span class=o>:</span> <span class=n>mName</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>mAge</span><span class=p>(</span><span class=n>age</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>printInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;name: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mName</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, age: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mAge</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>mName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ChangePersonCallByValue</span><span class=p>(</span><span class=n>Person</span> <span class=o>*</span><span class=n>argP</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>argP</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Kim&#34;</span><span class=p>,</span> <span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Park&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangePersonCallByValue</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>printInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>name: Park, age: 25
</code></pre><p><code>Person</code> 클래스는 이름과 나이를 가지고 있습니다. <code>main()</code>문을 살펴보면 이름 &ldquo;Park&rdquo;, 나이 25살이라는 <code>Person</code> 객체를 생성했습니다. 이를 call by value로 <code>ChangePersonCallByValue()</code> 함수에 전달했습니다. 그 후 해당 매개변수에 새로운 <code>Person</code> 객체를 할당하였습니다.</p><p>결과는 call by value이므로 원본에 영향을 미치지 못했습니다.</p><blockquote><p>여기서 잠깐 원본에 대해 알아보겠습니다. 제가 call by value와 call by reference를 구분짓는 중요한 부분은 원본에 대해 제가 생각했던 정의입니다. 위 <code>Person</code> 예제에서 변수 <code>p</code>의 원본은 무엇일까요? 대부분 내부의 name과 age 값이라고 생각합니다. 물론 그렇게 생각할 수 있지만, 원본을 내부의 데이터까지 포함하면 헷갈리기 시작합니다.</p><p>원본은 첫 번째 예제에서 살펴본 것과 같이 변수 <code>p</code> 그 자체입니다. 변수 <code>p</code>에는 생성한 <code>Person</code> 객체의 주소값이 있습니다. 제가 정의한 원본은 이 주소값에 <strong>한정</strong>합니다. 왜냐하면 변수 <code>p</code>는 <code>Person*</code> 자료형이며, 이는 <code>Person</code> 객체의 주소값을 저장하는 역할입니다. 변수 <code>p</code> 입장에서는 내부 데이터와는 연관이 없을 수 있겠다고 생각했습니다.</p></blockquote><p>말씀드린 원본의 정의를 위와 같이 하면 call by value와 call by reference는 정확히 구분된다고 생각합니다. 원본을 내부 값까지 다 포함한다고 생각하면, 아래 예제처럼 주소값이 전달되는 경우 원본을 변경할 수 있으므로 call by reference라고도 볼 수 있어 기준이 흔들립니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span> <span class=o>:</span> <span class=n>mName</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>mAge</span><span class=p>(</span><span class=n>age</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>changePerson</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span>   <span class=c1>// 1)
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>mName</span> <span class=o>=</span> <span class=n>name</span><span class=p>;</span>
</span></span><span class=line><span class=cl>        <span class=n>mAge</span> <span class=o>=</span> <span class=n>age</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>printInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;name: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mName</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, age: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mAge</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>mName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ChangePersonCallByValue</span><span class=p>(</span><span class=n>Person</span> <span class=o>*</span><span class=n>argP</span><span class=p>)</span> 
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>argP</span><span class=o>-&gt;</span><span class=n>changePerson</span><span class=p>(</span><span class=s>&#34;Kim&#34;</span><span class=p>,</span> <span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Park&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangePersonCallByValue</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>printInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>name: Kim, age: 30
</code></pre><p>위 예제는 똑같이 call by value로 전달하였는데, 결과는 내부 값이 변경되었습니다. 하지만 아래 <code>main()</code> 함수로 변경하여 실제 원본 값을 비교해보면 원본은 변경된 것이 아닙니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Park&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before call by value: p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangePersonCallByValue</span><span class=p>(</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>printInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After call by value: p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>Before call by value: p = 0x7f8a8c405830
name: Kim, age: 30
After call by value: p = 0x7f8a8c405830
</code></pre><p>현재까지는 객체만을 살펴봤지만, 배열도 같습니다. 배열 역시 이를 사용하는 변수는 가장 첫 번째를 가리키는 주소값이 저장되어있습니다. 그 외의 요소는 위에서 살펴본 객체 예제처럼 내부 값이라고 생각할 수 있습니다.</p><p>정리하면, call by value는 <strong>원본을 변경할 수 없습니다.</strong> value가 주소값을 포함해서 어떤 자료형의 값이 와도 실제 원본은 변경할 수 없습니다.</p><h2 id=call-by-reference>Call By Reference<a hidden class=anchor aria-hidden=true href=#call-by-reference>#</a></h2><p>Call by reference는 원본의 주소값을 전달하므로, 원본을 변경할 수 있습니다. 왜냐하면 주소값을 통해 원본에 접근할 수 있기 때문입니다. 그런데 중요한 점이 한 가지 있습니다. <strong>주소값을 저장할 수 있는 자료형을 제공</strong>해야 call by reference를 사용할 수 있습니다.</p><blockquote><p>원본의 주소값이라고 하면 원본이 할당되어 있는 메모리의 주소값을 말합니다. 따라서 원본의 값이 주소값인 것과 상관없이 어떤 종류의 값이라도 이에 할당되어 있는 메모리 주소가 있을 것입니다.</p></blockquote><p>원본의 주소값을 가질 수 있는 방법은 이를 저장할 수 있는 자료형이 존재한다는 의미와 동일합니다. 먼저 가장 대표적인 <code>Swap()</code> 예제를 살펴보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>void</span> <span class=nf>Swap</span><span class=p>(</span><span class=kt>int</span> <span class=o>*</span><span class=n>num1</span><span class=p>,</span> <span class=kt>int</span> <span class=o>*</span><span class=n>num2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>temp</span> <span class=o>=</span> <span class=o>*</span><span class=n>num1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>num1</span> <span class=o>=</span> <span class=o>*</span><span class=n>num2</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=n>num2</span> <span class=o>=</span> <span class=n>temp</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>a</span> <span class=o>=</span> <span class=mi>10</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>b</span> <span class=o>=</span> <span class=mi>20</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before Swap: &#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, b = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>Swap</span><span class=p>(</span><span class=o>&amp;</span><span class=n>a</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>b</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After Swap: &#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;a = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>a</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, b = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>b</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>Before Swap: a = 10, b = 20
After Swap: a = 20, b = 10
</code></pre><p>위 <code>Swap()</code> 함수는 int형 변수 두 개를 call by reference로 전달하여 서로 맞바꾸는 역할을 합니다. 결과를 보면 caller 함수 내부의 변경으로 callee 함수의 원본에 영향을 끼친 것을 알 수 있습니다.</p><p>이가 가능한 것은 위 예제에서 사용한 C++언어가 제공하는 <code>*</code>, <code>&</code> 키워드 때문입니다. 이 키워드에 대해서는 가장 첫번째 예제에서 설명했습니다. 짧게 요약하면 변수의 주소값을 추출하고, 이를 저장할 수 있는 키워드입니다.</p><p>위 예제를 스택 메모리로 살펴보면 더 쉽게 이해할 수 있을 것입니다.</p><blockquote><p>아래 메모리 그림은 매우 단순화한 것입니다.</p></blockquote><ul><li><code>Swap()</code> 함수 실행 전</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/230754696-5717b6c8-db0a-4b2b-93c6-7febdcbd1161.png alt=swap1></p><ul><li><code>Swap()</code> 함수 실행 후</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/230754707-81a13aa9-14ac-494d-b304-2666829d3397.png alt=swap2></p><p>위 그림의 주소값 2000부터 위로는 <code>Swap()</code> 함수의 메모리 공간입니다.</p><p>이렇게 C/C++과 같이 변수의 주소를 추출하고, 저장할 수 있는 키워드를 제공하는 언어는 call by reference를 할 수 있습니다. 하지만 이를 할 수 없는 Java는 call by reference를 할 수 없습니다.</p><p>그렇다면 C++에서 객체를 call by reference로 전달하는 예제를 살펴보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=k>class</span> <span class=nc>Person</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl><span class=k>public</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span><span class=p>(</span><span class=n>string</span> <span class=n>name</span><span class=p>,</span> <span class=kt>int</span> <span class=n>age</span><span class=p>)</span> <span class=o>:</span> <span class=n>mName</span><span class=p>(</span><span class=n>name</span><span class=p>),</span> <span class=n>mAge</span><span class=p>(</span><span class=n>age</span><span class=p>)</span> <span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=kt>void</span> <span class=nf>printInfo</span><span class=p>()</span>
</span></span><span class=line><span class=cl>    <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;name: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mName</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;, age: &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>mAge</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=k>private</span><span class=o>:</span>
</span></span><span class=line><span class=cl>    <span class=n>string</span> <span class=n>mName</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>mAge</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>ChangePersonCallByReference</span><span class=p>(</span><span class=n>Person</span> <span class=o>**</span><span class=n>argP</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=p>(</span><span class=o>*</span><span class=n>argP</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>(</span><span class=o>*</span><span class=n>argP</span><span class=p>)</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Kim&#34;</span><span class=p>,</span> <span class=mi>30</span><span class=p>);</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Park&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangePersonCallByReference</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>printInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>name: Kim, age: 30
</code></pre><p>위 예제는 call by value에서는 할 수 없었던 caller 함수 내부에서 원본에 새로운 <code>Person</code> 객체를 할당하는 모습입니다.</p><p><code>Person*</code> 자료형의 주소를 저장하기 위해 <code>*</code>키워드를 사용하여 <code>Person**</code> 자료형을 사용하였고, 이 주소를 추출하기 위해 <code>&</code> 키워드를 사용했습니다. 그렇다면 실제 주소값이 변경되는지 살펴보겠습니다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Person</span> <span class=o>*</span><span class=n>p</span> <span class=o>=</span> <span class=k>new</span> <span class=n>Person</span><span class=p>(</span><span class=s>&#34;Park&#34;</span><span class=p>,</span> <span class=mi>25</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Before call by reference: p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>ChangePersonCallByReference</span><span class=p>(</span><span class=o>&amp;</span><span class=n>p</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=n>p</span><span class=o>-&gt;</span><span class=n>printInfo</span><span class=p>();</span>
</span></span><span class=line><span class=cl>    <span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;After call by reference: p = &#34;</span> <span class=o>&lt;&lt;</span> <span class=n>p</span> <span class=o>&lt;&lt;</span> <span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>delete</span> <span class=n>p</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><pre tabindex=0><code>Before call by reference: p = 0x7ff858c05830
name: Kim, age: 30
After call by reference: p = 0x7ff858c05850
</code></pre><p>After에서 원본 값이 변경된 것을 볼 수 있습니다.</p><blockquote><p>위 변수 <code>p</code>의 값이 같게 나오시는 분들은 <code>ChangePersonCallByReference()</code> 함수안의 <code>delete (*argP);</code>를 지우고 실행해보시길 바랍니다. 워낙 간단한 로직이다 보니 delete한 메모리에 바로 새로운 객체를 할당하여 같은 주소값이 되는 경우가 있었습니다.</p></blockquote><p>이 예제 역시 <code>Swap()</code> 함수 예제처럼 메모리를 살펴보면 좀 더 쉽게 이해할 수 있을 것입니다.</p><ul><li><code>ChangePersonCallByReference()</code> 함수 실행 전</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/230754717-390c2254-c598-46ab-b5ec-1fff186153f3.png alt=before_calling_method></p><ul><li><code>ChangePersonCallByReference()</code> 함수 실행 후</li></ul><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/230754725-c0dc4924-13e0-4f86-95d1-b31d132c2628.png alt=after_calling_method></p><blockquote><p>C++에서 <code>new</code> 키워드로 객체를 생성하면 Heap 메모리에 할당됩니다.</p></blockquote><h2 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h2><p>지금까지 살펴본 것을 정리해보겠습니다.</p><ul><li>Call By Value: 원본 값을 그대로 복사하여 전달하며, 원본에 영향을 미칠 수 없습니다.</li><li>Call By Reference: 원본의 주소값을 복사하여 전달하며, 원본에 영향을 미칠 수 있습니다.<ul><li>변수의 주소값을 추출 및 저장하는 기능을 언어 차원에서 제공해주어야 call by reference가 가능합니다.</li></ul></li><li>C/C++는 Call By Value, Call By Reference 둘 다 가능하지만, Java는 Call By Value로만 동작할 수 있습니다.</li></ul><blockquote><p>C++로 call by reference를 사용하여 코딩하며 생각한 것이지만, call by reference를 사용하면 가독성이 안좋아진다고 생각합니다. 함수를 볼 때마다 매개변수로 전달받은 값이 원본에 영향을 주는지 주의깊게 살펴봐야합니다. 이러한 부분은 컨벤션을 정해놓고 코딩하는 것이 좋을 것 같습니다. (제가 알기로는 C++을 사용하는 회사의 컨벤션에 이와 관련된 것이 있는 것으로 알고 있습니다.)</p></blockquote></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/java/>Java</a></li><li><a href=https://parker1609.github.io/tags/c++/>C++</a></li><li><a href=https://parker1609.github.io/tags/call-by-value/>Call By Value</a></li><li><a href=https://parker1609.github.io/tags/call-by-reference/>Call By Reference</a></li></ul><nav class=paginav><a class=prev href=https://parker1609.github.io/post/intellij-idea-useful-plugin/><span class=title>« Prev</span><br><span>[IntelliJ IDEA] 유용한 플러그인 모음</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>