<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Kafka 101 - 카프카에 대한 소개와 주요 설정 | Parker Blog</title><meta name=keywords content="kafka,101"><meta name=description content="카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.
카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.
높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/kafka-101/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Kafka 101 - 카프카에 대한 소개와 주요 설정"><meta property="og:description" content="카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.
카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.
높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/kafka-101/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-05-07T12:39:08+09:00"><meta property="article:modified_time" content="2023-05-07T12:39:08+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Kafka 101 - 카프카에 대한 소개와 주요 설정"><meta name=twitter:description content="카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.
카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.
높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"Kafka 101 - 카프카에 대한 소개와 주요 설정","item":"https://parker1609.github.io/post/kafka-101/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Kafka 101 - 카프카에 대한 소개와 주요 설정","name":"Kafka 101 - 카프카에 대한 소개와 주요 설정","description":"카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.\n카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.\n높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다.","keywords":["kafka","101"],"articleBody":"카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.\n카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.\n높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다. 높은 압축률이 필요한 경우, gzip or zstd 권장 빠른 응답 속도가 필요한 경우, lz4 or snappy 권장 높은 확장성 고가용성 리플리케이션 (replication) 내구성 프로듀서 acks 설정 (저장 확인) 소비된 데이터는 바로 지우지 않음 (설정된 시간 또는 로그의 크기만큼 저장) 여러 브로커에 분산 저장 개발 편의성 프로듀서와 컨슈머는 독립적으로 개발 가능 카프카 커넥트, 스키마 레지스트리 등 여러 편의 기능 제공 운영 및 관리 편의성 이와 같은 많은 장점을 가지고 카프카는 현재 수많은 기업에서 사용하고 있는 메시징 시스템으로 자리잡았다. 이 글에서는 카프카의 기본 개념 및 중요하게 기억해야할 점과 설정에 관한 글이다. 카프카를 빠르게 파악하고 설정할 때 읽기 위한 목적으로 작성하였다.\n카프카 구성요소와 구조 카프카는 여러 용어를 사용하고 있어 초기에는 헷갈릴 수 있다. 아래 용어는 기본적으로 많이 사용하는 용어 위주로 설명하였다.\n주키퍼 (ZooKeeper)\n카프카의 메타데이터(metadata) 관리 및 브로커의 정상상태 점검(health check)을 담당하는 애플리케이션 Kafka or Kafka cluster\n카프카에서 여러 대의 브로커를 구성한 클러스터 브로커 (Broker)\n카프카 애플리케이션이 설치된 서버 또는 노드 프로듀서 (Producer)\n카프카로 메시지를 보내는 역할을 하는 클라이언트 컨슈머 (Consumer)\n카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트 토픽 (Topic)\n카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유하다. 파티션 (Partition)\n병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말한다. 세그먼트 (Segment)\n프로듀서가 전송할 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일 Message or Record\n프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각 위 구성요소를 그림으로 나타내면 아래와 같다.\n리플리케이션 (Replication) 위 그림을 보면 브로커가 똑같은 모습으로 3개 존재한다. 이를 리플리케이션이라고 부르며, 같은 데이터를 복제해놓는 것을 말한다. 리플리케이션을 하는 이유는 고가용성을 위함이다. 브로커가 하나가 장애가 발생하여 종료되어도 나머지 브로커가 살아있으므로 운영을 유지하는데는 문제가 되지 않는다. 이는 데이터를 계속 안전하게 유지할 수 있다는 의미이다.\n리플리케이션의 개수는 환경마다 추천하는 개수가 다르다.\n테스트나 개발 환경: 1 운영 환경 (로그성 메시지로서 약간의 유실 허용): 2 운영 환경 (유실 허용하지 않음): 3 참고로 브로커 개수가 3개인데, 리플리케이션 개수를 4개로 설정하면 같은 브로커 내에 2개가 저장되므로 비효율적이다.\n파티션 파티션은 토픽에 데이터를 저장하는 하나의 큐이다. 한 토픽의 여러 개의 파티션을 가질 수 있고, 이는 병렬 처리가 가능해져서 처리량을 높일 수 있다. 파티션의 특징은 다음과 같다.\n하나의 파티션은 데이터의 순서를 보장한다. (단, 여러 개의 파티션을 사용하면 순서를 보장할 수 없다.) 여러 개의 파티션은 각각의 컨슈머에 연결될 수 있다. 파티션 수와 컨슈머 수가 같으면 각각 1:1로 매핑될 수도 있고, 파티션 수가 더 많으면 하나의 컨슈머에 여러 개의 파티션이 매핑될 수도 있다. 파티션은 데이터 위치를 나타내는 오프셋을 가지고 있다. 오프셋 (offset) 오프셋은 파티션 내에 데이터의 위치를 나타내는 고유한 번호(64비트 정수)이다. 오프셋은 0부터 시작하며, 데이터가 증가함에 따라 순차적으로 증가한다. 오프셋의 역할은 다음과 같다.\n컨슈머가 파티션의 데이터를 어디까지 읽었는지 나타내는 지표 파티션의 데이터가 어디까지 보존되었는지 나타내는 지표 오프셋은 브로커 내에 영구적으로 저장되어 관리되는 데이터이다.\n프로듀서 프로듀서는 ProducerRecord라는 데이터 객체를 만들어서, Serializer, Partitioner 순서의 과정을 거쳐서 브로커로 전송한다.\nProducerRecord Topic (필수값): 어떤 토픽으로 보낼지 Value (필수값): 메시지 값 Partition: 특정 파티션으로 보낼지 지정 Key: 레코드들의 정렬을 위한 레코드 키 Serializer: 브로커로 전송하기 위한 데이터 형태로 만드는 작업 Partitioner: 어느 파티션으로 보낼 지 결정하는 과정 ProduceRecord의 값 중 Partition 이 지정된다면, Partitioner는 아무런 동작을 하지 않는다. 위가 아니면, 기본적으로 RR 방식으로 동작한다. 프로듀서 주요 옵션 bootstrap.servers: 클라이언트가 카프카 클러스터에 처음 연결하기 위한 호스트와 포트 정보 client.dns.lookup: 하나의 호스트에 여러 IP를 매핑해 사용하는 일부 환경에서 클라이언트가 하나의 IP와 연결하지 못할 경우에 다른 IP로 시도하는 설정. use_all_dns_ips가 기본값 (DNS에 할당된 호스트의 모든 IP를 쿼리하고 저장하고, 첫 번째 IP로 접근이 실패하면, 종료하지 않고 다음 IP로 접근을 시도한다.). resolve_canonical_bootstrap_servers_only 옵션은 커버로스(Kerberos) 환경에서 FQDN을 얻기 위한 용도로 사용한다. acks: 프로듀서가 카프카 토픽의 리더 측에 메시지를 전송한 후 요청을 완료하기를 결정하는 옵션. 0은 빠른 전송을 의미하지만, 일부 메시지 손실 가능성이 있음. 1은 리더가 메시지를 받았는지 확인하지만, 모든 팔로워를 전부 확인하지는 않는다. (대부분 기본값으로 1을 사용) all(-1)은 팔로워가 메시지를 받았는지 여부를 확인한다. 다소 느릴 수 있지만, 하나의 팔로워가 있는 한 메시지는 손실되지 않는다. buffer.memory: 프로듀서가 카프카 서버로 데이터를 보내기 위해 잠시 대기(배치 전송이나 딜레이 등)할 수 있는 전체 메모리 바이트 compression.type: 프로듀서가 메시지 전송 시 선택할 수 있는 압축 타입. none, gzip, snappy, lz4, zstd 중 원하는 타입 선택 가능 enable.idempotence: 설정을 true로 하는 경우 중복 없는 전송이 가능하며, 이와 동시에 max.in.flight.requests.per.connection은 5이하, retries는 0이상, acks는 all로 설정해야 한다. max.in.flight.requests.per.connection: 하나의 커넥션에서 프로듀서가 최대한 ACK 없이 전송할 수 있는 요청 수. 메시지의 순서가 중요하다면 1로 설정을 권장하지만, 성능은 다소 떨어진다. retries: 일시적인 오류로 인해 전송에 실패한 데이터를 다시 보내는 횟수 batch.size: 프로듀서는 동일한 파티션으로 보내는 여러 데이터를 함께 배치로 보내려고 시도한다. 적절한 배치 크기 설정은 성능에 도움을 준다. linger.ms: 배치 형태의 메시지를 보내기 전에 추가적인 메시지를 위해 기다리는 시간을 조정하고, 배치 크기에 도달하지 못한 상황에서 linger.ms 제한 시간에 도달했을 때 메시지를 전송한다. transactional.id: ‘정확히 한 번 전송’을 위해 사용하는 옵션이며, 동일한 TransactionalId에 한해 정확히 한 번을 보장한다. 옵션을 사용하기 전 enable.idempotence를 true로 설정한다. 전송 방식 중복없는 전송 적어도 한 번 전송(at-least-once) 최대 한 번 전송(at-most-once) 정확히 한 번 전송(exactly-once) 정확히 한 번 전송 컨슈머 consume 작업은 컨슈머 그룹으로 동작을 한다.\n컨슈머 그룹은 하나 이상의 컨슈머를 가지는 그룹이다. 파티션 수와 컨슈머 수는 일대일로 매핑되는 것이 이상적이다. 컨슈머 주요 옵션 bootstrap.servers: 프로듀서와 동일하게 브로커의 정보를 입력 fetch.min.bytes: 한 번에 가져올 수 있는 최소 데이터 크기 만약 지정한 크기보다 작은 경우, 요청에 응답하지 않고 데이터가 누적될 때까지 기다린다. group.id: 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자. 동일한 그룹 내의 컨슈머 정보는 모두 공유된다. heartbeat.interval.ms: 하트비트가 있다는 것은 컨슈머의 상태가 active임을 의미한다. session.timeout.ms와 밀접한 관계가 있으며, session.timeout.ms보다 낮은 값으로 설정해야 한다. 일반적으로 session.timeout.ms의 1/3로 설정한다. max.partition.fetch.bytes: 파티션당 가져올 수 있는 최대 크기 session.timeout.ms: 이 시간을 이용해, 컨슈머가 종료된 것인지를 판단한다. 컨슈머는 주기적으로 하트비트를 보내야 하고, 만약 이 시간 전까지 하트비트를 보내지 않았다면 해당 컨슈머는 종료된 것으로 간주하고 컨슈머 그룹에서 제외하고 리밸런싱을 시작한다. enable.auto.commit: 백그라운드로 주기적으로 오프셋을 커밋한다. auto.offset.reset: 카프카에서 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우에 다음 옵션으로 reset한다. earliest: 가장 초기의 오프셋값으로 설정 latest: 가장 마지막의 오프셋값으로 설정 none: 이전 오프셋값을 찾지 못하면 에러 fetch.max.bytes: 한 번의 가져오기 요청으로 가져올 수 있는 최대 크기 group.instance.id: 컨슈머의 고유한 식별자. 만약 설정한다면 static 멤버로 간주되어, 불필요한 리밸런싱을 하지 않는다. isolation.level: 트랜잭션 컨슈머에서 사용되는 옵션 read_uncommitted는 기본값으로 모든 메시지를 읽음 read_committed는 트랜잭션이 완료된 메시지만 읽음 max.poll.records: 한 번의 poll() 요청으로 가져오는 최대 메시지 수 partition.assignment.strategy: 파티션 할당 전략. 기본값은 range fetch.max.wait.ms: fetch.min.bytes에 의해 설정된 데이터보다 적은 경우 요청에 대한 응답을 기다리는 최대 시간. 참고자료 실전 카프카 개발부터 운영까지 ","wordCount":"1077","inLanguage":"en","datePublished":"2023-05-07T12:39:08+09:00","dateModified":"2023-05-07T12:39:08+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/kafka-101/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/ title=Home><span>Home</span></a></li><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>Kafka 101 - 카프카에 대한 소개와 주요 설정</h1><div class=post-meta><span title='2023-05-07 12:39:08 +0900 KST'>May 7, 2023</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%b9%b4%ed%94%84%ec%b9%b4apache-kafkahttpskafkaapacheorg%eb%9e%80 aria-label="카프카(Apache Kafka)란?"><a href=https://kafka.apache.org/>카프카(Apache Kafka)</a>란?</a></li><li><a href=#%ec%b9%b4%ed%94%84%ec%b9%b4-%ea%b5%ac%ec%84%b1%ec%9a%94%ec%86%8c%ec%99%80-%ea%b5%ac%ec%a1%b0 aria-label="카프카 구성요소와 구조">카프카 구성요소와 구조</a></li><li><a href=#%eb%a6%ac%ed%94%8c%eb%a6%ac%ec%bc%80%ec%9d%b4%ec%85%98-replication aria-label="리플리케이션 (Replication)">리플리케이션 (Replication)</a></li><li><a href=#%ed%8c%8c%ed%8b%b0%ec%85%98 aria-label=파티션>파티션</a><ul><li><a href=#%ec%98%a4%ed%94%84%ec%85%8b-offset aria-label="오프셋 (offset)">오프셋 (offset)</a></li></ul></li><li><a href=#%ed%94%84%eb%a1%9c%eb%93%80%ec%84%9c aria-label=프로듀서>프로듀서</a><ul><li><a href=#%ed%94%84%eb%a1%9c%eb%93%80%ec%84%9c-%ec%a3%bc%ec%9a%94-%ec%98%b5%ec%85%98 aria-label="프로듀서 주요 옵션">프로듀서 주요 옵션</a></li><li><a href=#%ec%a0%84%ec%86%a1-%eb%b0%a9%ec%8b%9d aria-label="전송 방식">전송 방식</a></li></ul></li><li><a href=#%ec%bb%a8%ec%8a%88%eb%a8%b8 aria-label=컨슈머>컨슈머</a><ul><li><a href=#%ec%bb%a8%ec%8a%88%eb%a8%b8-%ec%a3%bc%ec%9a%94-%ec%98%b5%ec%85%98 aria-label="컨슈머 주요 옵션">컨슈머 주요 옵션</a></li></ul></li><li><a href=#%ec%b0%b8%ea%b3%a0%ec%9e%90%eb%a3%8c aria-label=참고자료>참고자료</a></li></ul></div></details></div><div class=post-content><h1 id=카프카apache-kafkahttpskafkaapacheorg란><a href=https://kafka.apache.org/>카프카(Apache Kafka)</a>란?<a hidden class=anchor aria-hidden=true href=#카프카apache-kafkahttpskafkaapacheorg란>#</a></h1><blockquote><p>Apache Kafka is an open-source distributed event streaming platform used by
thousands of companies for high-performance data pipelines, streaming analytics,
data integration, and mission-critical applications.</p></blockquote><p>카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다.
카프카는 다음과 같은 특징을 가지고 있다.</p><ul><li>높은 처리량과 낮은 지연시간<ul><li>페이지 캐시</li><li>배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능)</li><li>압축 전송 (네트워크 통신 효율)<ul><li>배치와 같이 사용하면 효과가 더욱 커진다.</li><li>높은 압축률이 필요한 경우, gzip or zstd 권장</li><li>빠른 응답 속도가 필요한 경우, lz4 or snappy 권장</li></ul></li></ul></li><li>높은 확장성</li><li>고가용성<ul><li>리플리케이션 (replication)</li></ul></li><li>내구성<ul><li>프로듀서 acks 설정 (저장 확인)</li><li>소비된 데이터는 바로 지우지 않음 (설정된 시간 또는 로그의 크기만큼 저장)</li><li>여러 브로커에 분산 저장</li></ul></li><li>개발 편의성<ul><li>프로듀서와 컨슈머는 독립적으로 개발 가능</li><li>카프카 커넥트, 스키마 레지스트리 등 여러 편의 기능 제공</li></ul></li><li>운영 및 관리 편의성</li></ul><p>이와 같은 많은 장점을 가지고 카프카는 현재 수많은 기업에서 사용하고 있는 메시징 시스템으로 자리잡았다.
이 글에서는 카프카의 기본 개념 및 중요하게 기억해야할 점과 설정에 관한 글이다.
카프카를 빠르게 파악하고 설정할 때 읽기 위한 목적으로 작성하였다.</p><h1 id=카프카-구성요소와-구조>카프카 구성요소와 구조<a hidden class=anchor aria-hidden=true href=#카프카-구성요소와-구조>#</a></h1><p>카프카는 여러 용어를 사용하고 있어 초기에는 헷갈릴 수 있다. 아래 용어는 기본적으로 많이 사용하는 용어 위주로 설명하였다.</p><p>주키퍼 (ZooKeeper)</p><ul><li>카프카의 메타데이터(metadata) 관리 및 브로커의 정상상태 점검(health check)을 담당하는 애플리케이션</li></ul><p>Kafka or Kafka cluster</p><ul><li>카프카에서 여러 대의 브로커를 구성한 클러스터</li></ul><p>브로커 (Broker)</p><ul><li>카프카 애플리케이션이 설치된 서버 또는 노드</li></ul><p>프로듀서 (Producer)</p><ul><li>카프카로 메시지를 보내는 역할을 하는 클라이언트</li></ul><p>컨슈머 (Consumer)</p><ul><li>카프카에서 메시지를 꺼내가는 역할을 하는 클라이언트</li></ul><p>토픽 (Topic)</p><ul><li>카프카는 메시지 피드들을 토픽으로 구분하고, 각 토픽의 이름은 카프카 내에서 고유하다.</li></ul><p>파티션 (Partition)</p><ul><li>병렬 처리 및 고성능을 얻기 위해 하나의 토픽을 여러 개로 나눈 것을 말한다.</li></ul><p>세그먼트 (Segment)</p><ul><li>프로듀서가 전송할 실제 메시지가 브로커의 로컬 디스크에 저장되는 파일</li></ul><p>Message or Record</p><ul><li>프로듀서가 브로커로 전송하거나 컨슈머가 읽어가는 데이터 조각</li></ul><p>위 구성요소를 그림으로 나타내면 아래와 같다.</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/236656411-e94f74c4-3999-497b-8f61-91b73bdf53f1.png alt=image></p><h1 id=리플리케이션-replication>리플리케이션 (Replication)<a hidden class=anchor aria-hidden=true href=#리플리케이션-replication>#</a></h1><p>위 그림을 보면 브로커가 똑같은 모습으로 3개 존재한다. 이를 리플리케이션이라고 부르며, 같은 데이터를 복제해놓는 것을 말한다.
리플리케이션을 하는 이유는 고가용성을 위함이다. 브로커가 하나가 장애가 발생하여 종료되어도 나머지 브로커가 살아있으므로
운영을 유지하는데는 문제가 되지 않는다. 이는 데이터를 계속 안전하게 유지할 수 있다는 의미이다.</p><p>리플리케이션의 개수는 환경마다 추천하는 개수가 다르다.</p><ul><li>테스트나 개발 환경: 1</li><li>운영 환경 (로그성 메시지로서 약간의 유실 허용): 2</li><li>운영 환경 (유실 허용하지 않음): 3</li></ul><p>참고로 브로커 개수가 3개인데, 리플리케이션 개수를 4개로 설정하면 같은 브로커 내에 2개가 저장되므로 비효율적이다.</p><h1 id=파티션>파티션<a hidden class=anchor aria-hidden=true href=#파티션>#</a></h1><p>파티션은 토픽에 데이터를 저장하는 하나의 큐이다.
한 토픽의 여러 개의 파티션을 가질 수 있고, 이는 병렬 처리가 가능해져서 처리량을 높일 수 있다.
파티션의 특징은 다음과 같다.</p><ul><li>하나의 파티션은 데이터의 순서를 보장한다. (단, 여러 개의 파티션을 사용하면 순서를 보장할 수 없다.)</li><li>여러 개의 파티션은 각각의 컨슈머에 연결될 수 있다.<ul><li>파티션 수와 컨슈머 수가 같으면 각각 1:1로 매핑될 수도 있고, 파티션 수가 더 많으면 하나의 컨슈머에 여러 개의 파티션이 매핑될 수도 있다.</li></ul></li><li>파티션은 데이터 위치를 나타내는 오프셋을 가지고 있다.</li></ul><h2 id=오프셋-offset>오프셋 (offset)<a hidden class=anchor aria-hidden=true href=#오프셋-offset>#</a></h2><p>오프셋은 파티션 내에 데이터의 위치를 나타내는 고유한 번호(64비트 정수)이다.
오프셋은 0부터 시작하며, 데이터가 증가함에 따라 순차적으로 증가한다.
오프셋의 역할은 다음과 같다.</p><ul><li>컨슈머가 파티션의 데이터를 어디까지 읽었는지 나타내는 지표</li><li>파티션의 데이터가 어디까지 보존되었는지 나타내는 지표</li></ul><p>오프셋은 브로커 내에 영구적으로 저장되어 관리되는 데이터이다.</p><h1 id=프로듀서>프로듀서<a hidden class=anchor aria-hidden=true href=#프로듀서>#</a></h1><p>프로듀서는 ProducerRecord라는 데이터 객체를 만들어서, Serializer, Partitioner 순서의 과정을 거쳐서 브로커로 전송한다.</p><ul><li>ProducerRecord<ul><li>Topic (필수값): 어떤 토픽으로 보낼지</li><li>Value (필수값): 메시지 값</li><li>Partition: 특정 파티션으로 보낼지 지정</li><li>Key: 레코드들의 정렬을 위한 레코드 키</li></ul></li><li>Serializer: 브로커로 전송하기 위한 데이터 형태로 만드는 작업</li><li>Partitioner: 어느 파티션으로 보낼 지 결정하는 과정<ul><li>ProduceRecord의 값 중 Partition 이 지정된다면, Partitioner는 아무런 동작을 하지 않는다.</li><li>위가 아니면, 기본적으로 RR 방식으로 동작한다.</li></ul></li></ul><h2 id=프로듀서-주요-옵션>프로듀서 주요 옵션<a hidden class=anchor aria-hidden=true href=#프로듀서-주요-옵션>#</a></h2><ul><li><code>bootstrap.servers</code>: 클라이언트가 카프카 클러스터에 처음 연결하기 위한 호스트와 포트 정보</li><li><code>client.dns.lookup</code>: 하나의 호스트에 여러 IP를 매핑해 사용하는 일부 환경에서 클라이언트가 하나의 IP와 연결하지 못할 경우에 다른 IP로 시도하는 설정.<ul><li><code>use_all_dns_ips</code>가 기본값 (DNS에 할당된 호스트의 모든 IP를 쿼리하고 저장하고, 첫 번째 IP로 접근이 실패하면, 종료하지 않고 다음 IP로 접근을 시도한다.).</li><li><code>resolve_canonical_bootstrap_servers_only</code> 옵션은 커버로스(Kerberos) 환경에서 FQDN을 얻기 위한 용도로 사용한다.</li></ul></li><li><code>acks</code>: 프로듀서가 카프카 토픽의 리더 측에 메시지를 전송한 후 요청을 완료하기를 결정하는 옵션.<ul><li><code>0</code>은 빠른 전송을 의미하지만, 일부 메시지 손실 가능성이 있음.</li><li><code>1</code>은 리더가 메시지를 받았는지 확인하지만, 모든 팔로워를 전부 확인하지는 않는다. (대부분 기본값으로 1을 사용)</li><li><code>all(-1)</code>은 팔로워가 메시지를 받았는지 여부를 확인한다. 다소 느릴 수 있지만, 하나의 팔로워가 있는 한 메시지는 손실되지 않는다.</li></ul></li><li><code>buffer.memory</code>: 프로듀서가 카프카 서버로 데이터를 보내기 위해 잠시 대기(배치 전송이나 딜레이 등)할 수 있는 전체 메모리 바이트</li><li><code>compression.type</code>: 프로듀서가 메시지 전송 시 선택할 수 있는 압축 타입.<ul><li><code>none</code>, <code>gzip</code>, <code>snappy</code>, <code>lz4</code>, <code>zstd</code> 중 원하는 타입 선택 가능</li></ul></li><li><code>enable.idempotence</code>: 설정을 <code>true</code>로 하는 경우 중복 없는 전송이 가능하며, 이와 동시에 <code>max.in.flight.requests.per.connection</code>은 <code>5</code>이하, <code>retries</code>는 <code>0</code>이상, <code>acks</code>는 <code>all</code>로 설정해야 한다.</li><li><code>max.in.flight.requests.per.connection</code>: 하나의 커넥션에서 프로듀서가 최대한 ACK 없이 전송할 수 있는 요청 수. 메시지의 순서가 중요하다면 <code>1</code>로 설정을 권장하지만, 성능은 다소 떨어진다.</li><li><code>retries</code>: 일시적인 오류로 인해 전송에 실패한 데이터를 다시 보내는 횟수</li><li><code>batch.size</code>: 프로듀서는 동일한 파티션으로 보내는 여러 데이터를 함께 배치로 보내려고 시도한다. 적절한 배치 크기 설정은 성능에 도움을 준다.</li><li><code>linger.ms</code>: 배치 형태의 메시지를 보내기 전에 추가적인 메시지를 위해 기다리는 시간을 조정하고, 배치 크기에 도달하지 못한 상황에서 <code>linger.ms</code> 제한 시간에 도달했을 때 메시지를 전송한다.</li><li><code>transactional.id</code>: &lsquo;정확히 한 번 전송&rsquo;을 위해 사용하는 옵션이며, 동일한 <code>TransactionalId</code>에 한해 정확히 한 번을 보장한다. 옵션을 사용하기 전 <code>enable.idempotence</code>를 <code>true</code>로 설정한다.</li></ul><h2 id=전송-방식>전송 방식<a hidden class=anchor aria-hidden=true href=#전송-방식>#</a></h2><ul><li>중복없는 전송<ul><li>적어도 한 번 전송(at-least-once)</li><li>최대 한 번 전송(at-most-once)</li><li>정확히 한 번 전송(exactly-once)</li></ul></li><li>정확히 한 번 전송</li></ul><h1 id=컨슈머>컨슈머<a hidden class=anchor aria-hidden=true href=#컨슈머>#</a></h1><p>consume 작업은 컨슈머 그룹으로 동작을 한다.</p><ul><li>컨슈머 그룹은 하나 이상의 컨슈머를 가지는 그룹이다.</li><li>파티션 수와 컨슈머 수는 일대일로 매핑되는 것이 이상적이다.</li></ul><h2 id=컨슈머-주요-옵션>컨슈머 주요 옵션<a hidden class=anchor aria-hidden=true href=#컨슈머-주요-옵션>#</a></h2><ul><li><code>bootstrap.servers</code>: 프로듀서와 동일하게 브로커의 정보를 입력</li><li><code>fetch.min.bytes</code>: 한 번에 가져올 수 있는 최소 데이터 크기<ul><li>만약 지정한 크기보다 작은 경우, 요청에 응답하지 않고 데이터가 누적될 때까지 기다린다.</li></ul></li><li><code>group.id</code>: 컨슈머가 속한 컨슈머 그룹을 식별하는 식별자. 동일한 그룹 내의 컨슈머 정보는 모두 공유된다.</li><li><code>heartbeat.interval.ms</code>: 하트비트가 있다는 것은 컨슈머의 상태가 active임을 의미한다.<ul><li><code>session.timeout.ms</code>와 밀접한 관계가 있으며, <code>session.timeout.ms</code>보다 낮은 값으로 설정해야 한다. 일반적으로 <code>session.timeout.ms</code>의 1/3로 설정한다.</li></ul></li><li><code>max.partition.fetch.bytes</code>: 파티션당 가져올 수 있는 최대 크기</li><li><code>session.timeout.ms</code>: 이 시간을 이용해, 컨슈머가 종료된 것인지를 판단한다. 컨슈머는 주기적으로 하트비트를 보내야 하고, 만약 이 시간 전까지 하트비트를 보내지 않았다면 해당 컨슈머는 종료된 것으로 간주하고 컨슈머 그룹에서 제외하고 리밸런싱을 시작한다.</li><li><code>enable.auto.commit</code>: 백그라운드로 주기적으로 오프셋을 커밋한다.</li><li><code>auto.offset.reset</code>: 카프카에서 초기 오프셋이 없거나 현재 오프셋이 더 이상 존재하지 않는 경우에 다음 옵션으로 reset한다.<ul><li><code>earliest</code>: 가장 초기의 오프셋값으로 설정</li><li><code>latest</code>: 가장 마지막의 오프셋값으로 설정</li><li><code>none</code>: 이전 오프셋값을 찾지 못하면 에러</li></ul></li><li><code>fetch.max.bytes</code>: 한 번의 가져오기 요청으로 가져올 수 있는 최대 크기</li><li><code>group.instance.id</code>: 컨슈머의 고유한 식별자. 만약 설정한다면 static 멤버로 간주되어, 불필요한 리밸런싱을 하지 않는다.</li><li><code>isolation.level</code>: 트랜잭션 컨슈머에서 사용되는 옵션<ul><li><code>read_uncommitted</code>는 기본값으로 모든 메시지를 읽음</li><li><code>read_committed</code>는 트랜잭션이 완료된 메시지만 읽음</li></ul></li><li><code>max.poll.records</code>: 한 번의 <code>poll()</code> 요청으로 가져오는 최대 메시지 수</li><li><code>partition.assignment.strategy</code>: 파티션 할당 전략. 기본값은 range</li><li><code>fetch.max.wait.ms</code>: fetch.min.bytes에 의해 설정된 데이터보다 적은 경우 요청에 대한 응답을 기다리는 최대 시간.</li></ul><h1 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h1><ul><li><a href=http://www.yes24.com/Product/Goods/104410708>실전 카프카 개발부터 운영까지</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/kafka/>kafka</a></li><li><a href=https://parker1609.github.io/tags/101/>101</a></li></ul><nav class=paginav><a class=prev href=https://parker1609.github.io/post/review-of-conversational-ai/><span class=title>« Prev</span><br><span>대화형 AI 사용 후기와 그 미래... (feat. ChatGPT, Google Bard)</span></a>
<a class=next href=https://parker1609.github.io/post/java-web-history/><span class=title>Next »</span><br><span>자바 웹 기술 역사</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>