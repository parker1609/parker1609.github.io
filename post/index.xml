<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Parker Blog</title>
    <link>https://parker1609.github.io/post/</link>
    <description>Recent content in Posts on Parker Blog</description>
    <image>
      <title>Parker Blog</title>
      <url>https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 02 Jun 2024 17:38:57 +0900</lastBuildDate><atom:link href="https://parker1609.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>서버 이중화(Redundancy)</title>
      <link>https://parker1609.github.io/post/server-redundancy/</link>
      <pubDate>Sun, 02 Jun 2024 17:38:57 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/server-redundancy/</guid>
      <description>이중화 (Redundancy) 이중화는 시스템의 구성 요소를 2개(n개)로 중복시켜 한 구성 요소가 실패하더라도 다른 구성 요소가 그 역할을 대신 할 수 있도록 하는 것을 말합니다.
그러면, 어떤 구성 요소를 중복해야 할까요? 바로 SPoF(Single Point of Failure)에 해당하는 구성 요소입니다. SPoF는 시스템, 네트워크 또는 프로세스에서 단일 구성 요소가 실패할 경우 전체 시스템의 기능이 중단되는 지점을 의미합니다. 이렇게 하나의 구성 요소가 실패하여 전체 서비스를 중단시킬 수 있는 부분을 이중화해야 합니다.
이중화는 시스템의 고가용성(High Availability), 결함 감내(Fault Tolerance)를 보장하여 서비스의 연속성을 유지하고, 장애 발생 시 신속하게 대응할 수 있는 장점을 갖고 있습니다.</description>
    </item>
    
    <item>
      <title>[도서 서평] - 맡겨진 소녀 - 클레어 키건</title>
      <link>https://parker1609.github.io/post/foster-review/</link>
      <pubDate>Tue, 07 May 2024 05:05:23 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/foster-review/</guid>
      <description>책 제목: 맡겨진 소녀 저자: 클레어 키건 번역: 허진 출판사: 다산책방 발간일: 2023년 4월 21일 https://product.kyobobook.co.kr/detail/S000201621680 책을 읽기 전, 이 책을 읽게 된 계기는 평소 좋아하는 영화 평론가인 이동진님이 추천한 영상을 통해서였다.
https://youtu.be/ZZuD0EDOfwY?si=RLoqI3B5ZAvrQAhN&amp;amp;t=415
이 책의 저자인 클레어 키건은 감정적으로 섬세한 문장이 두드러진다고 이 영상에서는 설명한다. 그리고 대부분 책의 분량이 길지 않다는 것도 특징이었다. 오랜만에 소설을 읽고 싶었던 시기여서 더욱 매력적인 책으로 다가왔었다.
이 책의 원재는 &amp;lsquo;foster&amp;rsquo;이다.
이 의미를 ChatGPT에게 물어보면 다음과 같은 대답을 볼 수 있었다.</description>
    </item>
    
    <item>
      <title>2024년 Weekly Log</title>
      <link>https://parker1609.github.io/post/daily/2024-week-logs/</link>
      <pubDate>Mon, 06 May 2024 15:19:41 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/daily/2024-week-logs/</guid>
      <description>3월 3주차 2024년 3월 3주차 주간 기록입니다. 처음 작성한 것이다보니, 언제든지 형식은 변경될 수 있습니다. 그리고 3주차 이전에 했던 것들도 이 글에는 작성될 수 있습니다.
개발 &amp;ldquo;프로세스는 만들 때는 최대한 많은 고민을 통해 공들여야 한다. 프로세스를 실행할 때는 극단적으로 아무 생각없이 돌려도 문제가 없어야 한다.&amp;rdquo;
[책] 구글 엔지니어는 이렇게 일한다.
매일 읽는 책으로 이 책을 선정하였다. 책을 산지는 1년 가까이 된 것으로 기억하는데, 개발을 한지 만 3년이 넘어간 시점에서 어떤 개발자가 될지 고민이 되어 이 책을 읽게 되었다.</description>
    </item>
    
    <item>
      <title>[MyBlog] 게시글에 이미지 삽입하기</title>
      <link>https://parker1609.github.io/post/blog/how-to-insert-image-in-my-blog/</link>
      <pubDate>Sat, 20 Apr 2024 11:59:18 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/blog/how-to-insert-image-in-my-blog/</guid>
      <description>Github 블로그와 같은 static 블로그를 운영할 때, 불편한 점 중 한 가지는 이미지를 삽입하는 과정이 번거롭다는 것이다.
먼저, 마크다운에서 이미지를 가져오는 문법에 대해서 알아보자.
![image_name](URL or Path) 이미지의 URL 또는 이미지 파일이 저장되어있는 Path 둘 다 사용할 수 있다. 그러다보니, 보여주고 싶은 이미지를 설정하는 방법 또한 두 가지이다.
외부 저장소에 올려서 URL 가져오기 삽입할 이미지를 외부 저장소에 올린 후, 생성된 URL을 사용하는 것이다.
여기서 외부 저장소는 대부분 Github를 사용한다. 특히, 현재 블로그는 Github 리포지토리를 활용하고 있어서 같은 곳에 저장을 하고 있으면 관리하기가 좋다.</description>
    </item>
    
    <item>
      <title>ChatGPT 활용하기 - Part 2</title>
      <link>https://parker1609.github.io/post/ai/utilizing-chatgpt-part-2/</link>
      <pubDate>Sun, 14 Apr 2024 11:54:25 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/ai/utilizing-chatgpt-part-2/</guid>
      <description>1편에서는 GPT 모델과 ChatGPT에 대해서 전반적으로 살펴보고, 이를 효율적으로 사용하기 위해 필요한 프롬프트 기법에 대해서 다루었습니다. ChatGPT 4가 나오면서 답변의 퀄리티가 향상된 것은 물론, 흥미롭고 편리한 기능들이 추가되었습니다.
ChatGPT 4를 사용하기 위해서는 ChatGPT Plus 구독이 필수적으로 필요합니다. (월 20$)
이번 2편에서는 ChatGPT 3.5와 비교하여 4 버전에서는 어떤 점이 달라졌는지와 추가된 기능, 그리고 이를 활용하는 방법에 대해서 알아보겠습니다. 마지막에는 ChatGPT 5 소식과 ChatGPT 외의 다른 LLM 서비스는 어떤 것이 있는지 간단히 살펴볼 예정입니다.</description>
    </item>
    
    <item>
      <title>TDD, 클린 코드 with Kotlin 7기 후기</title>
      <link>https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/</link>
      <pubDate>Sun, 28 Jan 2024 18:34:34 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/review-of-the-7th-edition-tdd-and-clean-code-with-kotlin/</guid>
      <description>Next step에서 진행하는 ‘TDD, 클린 코드 with Kotlin 7기’ 강의를 들은지 벌써 2달이 지났다. 후기를 작성을 빨리 하고 싶었지만, 업무를 병행하면서 미션을 모두 진행했다는 뿌듯함에 너무 오랫동안 미루게 되었다. 이제야 부랴부랴 작성해본다… (강의 링크: https://edu.nextstep.camp/c/Z9QeJlCi/)
코틀린은 백엔드 개발쪽에서도 자바와 비교하여 대체할만한 언어로 몇 년간 화두에 올랐었습니다. 그래서 계속 관심을 갖고는 있었지만 딱히 공부를 하지는 않았었습니다. 첫 째는 자바도 충분히 빠르게 발전하고 있었다고 생각하였고, 다니고 있던 회사에서도 코틀린은 거의 사용하지 않아서 동기부여가 되지 않았었습니다.</description>
    </item>
    
    <item>
      <title>ChatGPT 활용하기 - Part 1</title>
      <link>https://parker1609.github.io/post/ai/utilizing-chatgpt-part-1/</link>
      <pubDate>Thu, 18 Jan 2024 07:19:57 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/ai/utilizing-chatgpt-part-1/</guid>
      <description>ChatGPT는 현재 어떤 분야에 있는 사람이든 한 번쯤은 들어보거나 직접 사용해보았을 것입니다. 요즘은 AI라고 하면 가장 먼저 떠올릴 만큼 대명사로 자리잡은 것으로 보입니다. 그만큼 AI에 대해서 사람들이 이제는 피부로 느껴질 만큼 일상생활에 영향을 주고 있습니다.
저 역시 작년부터 꾸준히 사용해오고 있는 사용자로서, 무엇보다 놀라운 점은 ChatGPT가 저의 개발 스타일에도 큰 변화를 준 것입니다. 써보신 분들이라면 공감할 수 있겠지만, 구글링한다거나 스택 오버플로우에 접속하는 시간이 매우 적어졌습니다. 내가 원하는 것을 말로 표현하면, (심지어 추상적으로 간단히만 표현해도) 그에 맞게 적절히 정리해주고 답변을 주기 때문에 시간이 많이 단축되고 효율적이었습니다.</description>
    </item>
    
    <item>
      <title>2023년 마무리</title>
      <link>https://parker1609.github.io/post/retrospect/2023-retorspect/</link>
      <pubDate>Mon, 01 Jan 2024 14:17:11 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/retrospect/2023-retorspect/</guid>
      <description>개발 스터디 2월 ~ 5월: [사내 스터디] 인프런 강의 - 토비의 스프링 부트 - 이해와 원리 4월 ~ 8월: [Over-10 스터디] 책 - 이벤트 기반 마이크로서비스 구축 7월 ~ 11월: [사내 스터디] 인프런 강의 - 카프카 완벽 가이드 - 코어편 10월: [Monday9PM] 글 작성 및 발표 - 소프트웨어 테스트 12월: [Monday9PM] 글 작성 및 발표 - 객체를 다루는 다양한 방식 (with Java) 작성 글 2월 Hugo 블로그 생성 과정 (theme PaperMod) Java 11 vs Java 17 자바 웹 기술 역사 5월 [Kafka] 101 - 카프카에 대한 소개와 주요 설정 Spring Boot에서 카프카 사용하기 8월 MyBatis 필드 및 파라미터 매핑 (with.</description>
    </item>
    
    <item>
      <title>객체를 다루는 다양한 방식 (with Java)</title>
      <link>https://parker1609.github.io/post/dfferenet-ways-to-deal-with-object/</link>
      <pubDate>Mon, 11 Dec 2023 14:31:57 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/dfferenet-ways-to-deal-with-object/</guid>
      <description>이번글에서는 객체지향언어, 특히 자바에서 객체를 다루는 다양한 방식에 대해서 알아봅니다.
1. Object References 객체(Object)를 생성해서 사용하려면, 언어에서는 필연적으로 변수에 객체를 담아야합니다. 이 변수에 담기는 것은 객체를 참조(Reference)하는 주소값입니다. 이를 Object Reference라고 부르고, 객체를 다루는 언어에서 객체를 사용하는 방법입니다.
간단한 영화 예제를 살펴보겠습니다.
// Movie Object public class Movie { private String title; private String directorName; private int runningTime; // 생성자 생략 } // Object Reference Movie movie = new Movie(&amp;#34;오펜하이머&amp;#34;, &amp;#34;크리스토퍼 놀란&amp;#34;, 180); 생성한 Movie 객체는 메모리 어딘가에 저장이 될 것이고, movie 변수는 이 저장된 메모리의 시작 주소값을 할당받습니다.</description>
    </item>
    
    <item>
      <title>소프트웨어 테스트</title>
      <link>https://parker1609.github.io/post/software-test/</link>
      <pubDate>Mon, 30 Oct 2023 14:25:52 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/software-test/</guid>
      <description>소프트웨어를 개발하면서 테스트에 대한 중요성은 많이 알려져있습니다. 테스트는 크게 수동 테스트와 자동화된 테스트 두 가지로 나뉩니다. 수동 테스트는 말그대로 손으로 직접 테스트를 하는 것으로 기능을 직접 실행하여 테스트합니다. 이는 테스트 환경을 설정하거나 테스트 과정을 직접 따라하는 과정의 시간이 오래 걸리고, 같은 테스트를 반복하기가 어렵습니다. 그리고 사람의 눈으로 확인하는 것이기 때문에 실수할 확률이 높아 신뢰도가 떨어집니다.
반면에 자동화된 테스트는 일련의 스크립트를 작성하여 이 스크립트를 실행하는 것만으로 테스트가 완료됩니다. 스크립트를 잘 작성해야하는 어려움이 있지만, 한 번 작성한 테스트는 실행 한 번으로 모든 테스트를 할 수 있고 쉽게 반복할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Kubernetes 이슈 및 해결 방법 모음</title>
      <link>https://parker1609.github.io/post/issues/kubernetes-my-issues/</link>
      <pubDate>Sun, 15 Oct 2023 10:15:13 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/issues/kubernetes-my-issues/</guid>
      <description>Ingress에서 URL Path를 통한 라우팅 문제 상황 아래 상황은 실제로 발생한 이슈가 아닌, 이해를 돕기 위해 만든 가상의 상황입니다.
parker-movie 앱에서 영화의 정보를 조회할 수 있는 GET /movies/{movieId} API가 존재한다. 그런데, movieId 100번은 너무 유명한 영화라 조회 빈도가 높았고 부하가 심해졌다. 이를 해결하는 다양한 방식이 있겠지만, 여기서는 쿠버네티스 환경에서 pod 중 movieId 100번을 위한 pod을 따로 사용하고 싶었다. 이를 위해서 Ingress에서 URL Path를 통한 라우팅을 사용할 수 있다.
적용 apiVersion: apps/v1 kind: Deployment metadata: name: parker-movie-normal-app labels: app: parker-movie-normal-app spec: selector: matchLabels: app: parker-movie-normal-app replicas: 2 template: metadata: labels: app: parker-movie-normal-app spec: containers: - name: parker-movie image: parker-movie:latest imagePullPolicy: Always ports: - containerPort: 8081 env: - name: SPRING_PROFILES_ACTIVE value: real --- apiVersion: apps/v1 kind: Deployment metadata: name: parker-movie-100-app labels: app: parker-movie-100-app spec: selector: matchLabels: app: parker-movie-100-app replicas: 2 template: metadata: labels: app: parker-movie-100-app spec: containers: - name: parker-movie image: parker-movie:latest imagePullPolicy: Always ports: - containerPort: 8081 env: - name: SPRING_PROFILES_ACTIVE value: real --- apiVersion: v1 kind: Service metadata: labels: app: parker-movie-normal-svc name: parker-movie-normal-svc spec: ports: - port: 80 protocol: TCP targetPort: 8081 selector: app: parker-movie-normal-app type: ClusterIP --- apiVersion: v1 kind: Service metadata: labels: app: parker-movie-100-svc name: parker-movie-100-svc spec: ports: - port: 80 protocol: TCP targetPort: 8081 selector: app: parker-movie-100-app type: ClusterIP --- apiVersion: networking.</description>
    </item>
    
    <item>
      <title>Postgresql 이슈 및 해결 방법 모음</title>
      <link>https://parker1609.github.io/post/issues/postgresql-my-issues/</link>
      <pubDate>Sun, 15 Oct 2023 10:10:20 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/issues/postgresql-my-issues/</guid>
      <description>버전에 따른 파티션 테이블 인덱싱, 버전 10 VS 버전 11 Postgresql은 파티션 테이블을 생성하는 과정에서 헤더(부모) 테이블을 정의하는데 여기에 인덱스 정보를 선언할 수 있다. Postgresql 버전 10까지는 헤더 테이블로 생성한 하위 파티션 테이블에는 부모 테이블에 적용한 인덱스가 생성되지 않았다. 하지만 버전 11부터는 부모 테이블에 적용된 인덱스가 생성된 하위 테이블에도 똑같이 적용이 됩니다.
여러 환경에서 같은 파티션 테이블을 사용하면서 같은 쿼리를 동작시켰는데 속도가 전혀 다르다면, 일단 실행계획을 살펴보자. 그 결과 어떤 환경은 인덱스가 적용되고, 다른 환경은 인덱스가 적용되지 않는다면 Postgresql 버전을 의심해보자.</description>
    </item>
    
    <item>
      <title>LLM AI 후기와 내 생각</title>
      <link>https://parker1609.github.io/post/think/review-of-conversational-ai/</link>
      <pubDate>Sat, 02 Sep 2023 17:44:21 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/think/review-of-conversational-ai/</guid>
      <description>2023년은 개발을 넘어 세계적으로 가장 핫한 키워드는 &amp;lsquo;ChatGPT&amp;rsquo;일 것이다. 이는 간단히 말하면 챗봇과 같은 AI인데, 대화형 AI, 챗봇 AI, 대규모 언어 모델(LLM) AI 등으로 불리우고 있다. 이를 직접 사용해본 경험과 그 미래에 대해서 내 개인적인 의견을 적어보려한다.
History 2023-03: ChatGPT 3.5 버전(무료 버전) 사용 2023-03-26: ChatGPT Plus 유료 버전 사용 2023-05-10: Google Bard 한국어 버전 지원 (이 때쯤 잠깐 사용해봄.) 2023-05-26: ChatGPT Plus 유료 버전 사용 종료 2023-08: Github Copilot 사용 시작 ChatGPT ChatGPT에 대한 설명은 이를 직접 chatGPT에 물어본 내용을 약간 정리만 해보았다.</description>
    </item>
    
    <item>
      <title>개발자 학습</title>
      <link>https://parker1609.github.io/post/think/developer-study/</link>
      <pubDate>Sat, 02 Sep 2023 17:39:43 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/think/developer-study/</guid>
      <description>토비님 인프런의 한 질문에 대한 답변 (질문 링크) 토비님 답변 발췌
어려운 질문을 해주셨네요.
기술 공부에 비법은 없습니다. 각자 자신이 해야하는 일에 절박감을 가지고, 이 기술을 어떻게 써야 내가 원하는 결과를 가져올 수 있는지 열심히 찾는 수 밖에요. 당장 해야하는 일을 해결할 때는 모든 방법을 다 동원해서 코드를 만들어야죠. 다만, 이런 방식을 지속하면 생산성은 안 오르고, 응용력도 떨어지고 결정적으로 재미가 없습니다.
그래서 공부를 하는데요. 이건 사람마다 선호하는 스타일이 다른 것 같습니다.</description>
    </item>
    
    <item>
      <title>MyBatis 필드 및 파라미터 매핑 (with. Spring Boot)</title>
      <link>https://parker1609.github.io/post/mybatis-mapping/</link>
      <pubDate>Sun, 27 Aug 2023 17:20:12 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/mybatis-mapping/</guid>
      <description>이 글은 Spring Boot 환경에서 MyBatis를 사용할 때, 기본적인 조회 결과의 매핑에 대해 정리한 글이다.
이 글에 나오는 예제는 이 링크에서 확인할 수 있다.
Spring Boot 3.1.3 Java 17 mybatis-spring-boot-starter 3.0.2 mybatis 3.5.13 H2 Database 0. 예제 소개 매핑 테스트를 위한 간단한 영화(Movie) 예제를 살펴보자. 영화에 대한 정보를 저장하고 조회하는 서비스이다. 이 서비스의 ERD는 간단히 다음과 같이 만들어보았다.
Movie에 대한 DB 스키마는 다음과 같이 표현할 수 있다. (H2 Database 기준)</description>
    </item>
    
    <item>
      <title>2023년 전세집 이사</title>
      <link>https://parker1609.github.io/post/daily/2023-a-move/</link>
      <pubDate>Sun, 20 Aug 2023 10:33:30 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/daily/2023-a-move/</guid>
      <description>서울로 독립을 하면서 3년간 낙성대역 근처 3평 남짓한 원룸에서 지냈다. 원래는 2년을 지내고 이사를 가려고 했었다. 그런데 몇 가지 문제로 1년 더 연장을 해서 총 3년을 지내게 되었다.
Part 1. 2022년 이사 실패 2022년 여름 낙성대역 원룸 2년 계약이 끝나가고 있었다. 나는 다음 이사할 곳으로 전세 원룸 오피스텔을 알아보고 있었고, 이 당시 회사는 풀재택을 하고 있어서 위치는 크게 중요하지 않았다. 그래서 여러 후보 지역이 있었다. 미사역, 거여역, 모란역, 상현역, &amp;hellip; 등 신도시거나 원룸 오피스텔이 모여있는 깨끗한 동네 그리고 산책할 곳이 있는 곳 위주로 찾아보았다.</description>
    </item>
    
    <item>
      <title>Spring Boot에서 카프카 사용하기</title>
      <link>https://parker1609.github.io/post/spring-boot-kafka/</link>
      <pubDate>Mon, 29 May 2023 10:27:57 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/spring-boot-kafka/</guid>
      <description>이 글의 코드는 해당 링크에서 확인할 수 있습니다.
목표 Spring Boot 에서 Apache Kafka 사용 방법
자주 사용하는 설정 정리
테스트 개발 환경 Spring Boot 3.1.0
Java 17
Spring Kafka 3.0.7
kafka-client 3.4.0 Gradle
Docker
Broker 테스트 개발 환경에서는 카프카를 로컬에서 Docker 파일로 띄우고, Spring 서버에서 이를 연결한다.
로컬에서 Docker로 Apache Kafka 실행하기 kafka docker image 비교 bitnami
confluentinc
wurstmeister
링크 다운로드 수 star 수 특징 confluentinc Kafka / Zookeeper 100M+ 394 confluent 에서 제공하는 기능이 포함 bitnami Kafka / Zookeeper 100M+ 669 순수 카프카 이미지 wurstmeister Kafka / Zookeeper 100M+ 1.</description>
    </item>
    
    <item>
      <title>[Kafka] 101 - 카프카에 대한 소개와 주요 설정</title>
      <link>https://parker1609.github.io/post/kafka-101/</link>
      <pubDate>Sun, 07 May 2023 12:39:08 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/kafka-101/</guid>
      <description>카프카(Apache Kafka)란? Apache Kafka is an open-source distributed event streaming platform used by thousands of companies for high-performance data pipelines, streaming analytics, data integration, and mission-critical applications.
카프카는 대용량의 실시간 데이터 스트리밍 플랫폼으로서, 분산형 메시지 큐 시스템으로 동작한다. 카프카는 다음과 같은 특징을 가지고 있다.
높은 처리량과 낮은 지연시간 페이지 캐시 배치 전송 처리 (프로듀서 및 컨슈머는 단 건이 아닌 여러 개로 처리 가능) 압축 전송 (네트워크 통신 효율) 배치와 같이 사용하면 효과가 더욱 커진다.</description>
    </item>
    
    <item>
      <title>자바 웹 기술 역사</title>
      <link>https://parker1609.github.io/post/java-web-history/</link>
      <pubDate>Sun, 26 Feb 2023 14:45:58 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/java-web-history/</guid>
      <description>1. CGI (Common Gateway Interface) World Wide Web(WWW)은 초기에는 데이터가 동적으로 변하는 것에 대한 생각은 하지 않아 정적인 페이지 위주로 개발이 되었다. 시간이 흘러 웹은 점점 더 많은 데이터를 보여주도록 변하였고, 사용자가 필요에 따라 바로바로 데이터를 보여주는 동적인 페이지에 대한 수요가 늘었다. 동적인 페이지의 예제는 요즘은 흔히 찾아볼 수 있다. 웹 화면 사이드에 여러 광고가 보인다거나, 게시글이 보여지고 내가 보고 싶은 게시글을 검색한다거나, 댓글을 다는 등의 행동은 모두 동적인 페이지에서 이루어진다.</description>
    </item>
    
    <item>
      <title>Java 11 vs Java 17</title>
      <link>https://parker1609.github.io/post/java-11-vs-java-17/</link>
      <pubDate>Fri, 24 Feb 2023 11:53:53 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/java-11-vs-java-17/</guid>
      <description>1. 지원기간 https://www.oracle.com/java/technologies/java-se-support-roadmap.html
자바 11버전은 최대 2026년 9월까지 지원 자바 17버전은 최대 2029년 9월까지 지원 2. Java 11 VS 17, 주요 변경사항 아래 예제 코드의 전체는 https://github.com/programming-starter/java-17-starter 이 링크에서 확인할 수 있습니다.
Text Blocks 문자열을 좀 더 읽기 좋게 표현할 수 있게 되었다. 특히 JSON과 같은 문자열을 표현할 때, 예전에는 다음과 같이 표현해야 했다.
{ &amp;#34;name&amp;#34;: &amp;#34;parker&amp;#34;, &amp;#34;age&amp;#34;: 30, &amp;#34;job&amp;#34;: &amp;#34;Programmer&amp;#34; } @Test void old_style() { var json = &amp;#34;{\n&amp;#34; + &amp;#34; \&amp;#34;name\&amp;#34;: \&amp;#34;parker\&amp;#34;,\n&amp;#34; + &amp;#34; \&amp;#34;age\&amp;#34;: 30,\n&amp;#34; + &amp;#34; \&amp;#34;job\&amp;#34;: \&amp;#34;Programmer\&amp;#34;\n&amp;#34; + &amp;#34;}&amp;#34;; System.</description>
    </item>
    
    <item>
      <title>[MyBlog] Hugo 블로그 생성 과정 (theme PaperMod)</title>
      <link>https://parker1609.github.io/post/blog/creating-my-blog-with-hugo/</link>
      <pubDate>Sun, 19 Feb 2023 15:09:26 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/blog/creating-my-blog-with-hugo/</guid>
      <description>1. Hugo 설치 및 블로그 테마 설정 Mac OS 기준
1.1. Hugo 설치하기 # Hugo 설치 brew install hugo # hugo 버전 확인 hugo version &amp;gt; hugo v0.104.3+extended darwin/amd64 BuildDate=unknown 1.2. Hugo 블로그 만들기 &amp;amp; PaperMod 테마 설치하기 Hugo 블로그 역시 여러가지 테마를 가지고 있고, 이는 이 링크에서 확인할 수 있다. 그 중 PaperMod 테마가 깔끔하고 마음에 들어 선택하였다. 테마마다 블로그 설정이 조금씩 달라질 수 있으므로, 테마의 레퍼런스도 꼼꼼히 확인해보기를 추천한다.</description>
    </item>
    
    <item>
      <title>동적 프록시(Dynamic Proxy) with Spring Framework</title>
      <link>https://parker1609.github.io/post/dynamic-proxy-with-spring/</link>
      <pubDate>Sun, 04 Sep 2022 09:17:32 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/dynamic-proxy-with-spring/</guid>
      <description>디자인 패턴 글 중 프록시 패턴과 데코레이터 패턴에서 프록시를 코드로 구현하는 방법을 알아보았다. (이전 글 참고) 그런데 프록시를 적용해야 할 클래스가 수십 개에서 수백 개가 되면 어떻게 될까? 이러한 프록시 클래스를 그 개수만큼 반복해서 만들어주어야 한다.
이러한 불편함을 해소하기 위해 나온 기술이 동적 프록시(Dynamic Proxy)이다. 동적 프록시는 말그대로 동적인 시점(런타임 시점)에 프록시를 자동으로 만들어서 적용해주는 기술이다.
자바에서 대표적인 동적 프록시 기술은 JDK 동적 프록시와 CGLIB(Code Generator LIBrary)이 있다. 두 기술 모두 동적 프록시를 만들어주지만, 차이점은 다음과 같다.</description>
    </item>
    
    <item>
      <title>[디자인 패턴] 프록시 패턴/데코레이터 패턴</title>
      <link>https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/</link>
      <pubDate>Thu, 25 Aug 2022 09:12:33 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/design-pattern-proxy-pattern-and-decorator-pattern/</guid>
      <description>이 글은 디자인 패턴에서 유사한 패턴인 프록시 패턴과 데코레이터 패턴에 대해 알아본다. 두 패턴은 사실 ‘프록시(proxy)’를 사용하는 패턴이다. 프록시의 뜻은 ‘대리자&amp;rsquo;라는 뜻인데, 뜻처럼 어떤 일을 대신 해주는 역할을 한다.
프록시는 소프트웨어 환경에서 다양한 곳에서 활용되는 용어인데, 근본적인 기능은 크게 2 가지로 나뉜다.
접근 제어 권한에 따른 접근 차단 캐싱 (캐싱되어 있는 값은 접근할 필요가 없으므로, 캐시는 접근 제어의 역할) 지연 로딩 부가 기능 추가 값 변경 로깅 필터링 … 프록시 패턴과 데코레이터 패턴은 둘 다 프록시 개념을 사용하지만, 의도에 따라 나뉜다.</description>
    </item>
    
    <item>
      <title>[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴</title>
      <link>https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/</link>
      <pubDate>Fri, 19 Aug 2022 10:47:30 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/</guid>
      <description>이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.
패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.
전체 예제 코드는 이 링크에서 볼 수 있습니다.
예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다.</description>
    </item>
    
    <item>
      <title>[개발자가 알아야 할 네트워크 기초] IP 주소, Port 번호</title>
      <link>https://parker1609.github.io/post/network-basic-ip-address-and-port-number/</link>
      <pubDate>Wed, 27 Jul 2022 09:59:18 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/network-basic-ip-address-and-port-number/</guid>
      <description>IP 주소 IP(Internet Protocol) 주소: Host에 대한 식별자 IPv4 VS IPv6 주소 길이 IPv4: 32bit IPv6: 128bit 2022년 기준, IPv4를 대부분 사용함. IPv4의 전체 경우의 수는 2^32 (대략 42억)이며, 전체 Host를 모두 나타낼 수는 없으므로 IPv6 체계가 나왔다. IP 주소 = Network ID + Host ID Network ID를 계산하기 위해 서브넷 마스크(넷 마스크)가 존재한다. Host ID 길이는 전체 길이 32bit에서 NetworkID를 제외한 길이이다. 예제) IPv4: 172.20.10.2, 서브넷 마스크: 255.255.255.0 Network ID = 172.</description>
    </item>
    
    <item>
      <title>[개발자가 알아야 할 네트워크 기초] TCP/IP 개요</title>
      <link>https://parker1609.github.io/post/network-basic-tcp-and-ip/</link>
      <pubDate>Wed, 27 Jul 2022 09:03:05 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/network-basic-tcp-and-ip/</guid>
      <description>OSI 7 계층을 처음부터 공부하는 것은 추천하지 않는다. 웹 개발자라면, TCP/IP, HTTP 부터 정확히 파악하는게 중요하다.
TCP/IP 모델은 OSI 7 계층 또는 DoD 모델의 구현체이다. 구체적인 순서: TCP/IP Model(가장 구체적) &amp;gt; Dod Model &amp;gt; OSI 7 Layers 프로세스는 TCP의 데이터를 소켓 형태로 접근할 수 있다. 여기서, 소켓은 User Application와 TCP가 서로 접근할 수 있도록 파일 형태로 추상화한 것이다. 식별자 Access Layer: MAC 주소(L2) → NIC(LAN 카드)에 대한 식별자 NIC이 2개가 있는 경우(일반적으로 유선, 무선 랜 카드), MAC 주소도 2개가 된다.</description>
    </item>
    
    <item>
      <title>[Spring Boot &#43; JPA &#43; PostgreSQL] 다양한 기본키(PK) 생성 방식과 주의사항</title>
      <link>https://parker1609.github.io/post/spring-boot-and-jpa-and-postgresql-generating-primary-key/</link>
      <pubDate>Wed, 01 Jun 2022 10:06:13 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/spring-boot-and-jpa-and-postgresql-generating-primary-key/</guid>
      <description>해당 글의 예제 코드는 이 링크를 참조해주세요.
JPA에서 엔티티의 PK 생성 방법은 여러가지가 존재합니다. JPA에서 제공해주는 방식과 이를 PostgreSQL에서 사용했을 때, 어떻게 동작하는지 그리고 어떤 주의할 사항이 있는지 살펴보겠습니다.
1. @GeneratedValue 사용하지 않는 경우 @GeneratedValue 어노테이션을 사용하지 않는 경우, 반드시 엔티티를 생성할 때, 직접 id 값을 지정해주어야 한다. 그렇지 않은 경우, 아래와 같은 에러가 발생한다.
ids for this class must be manually assigned before calling save() 엔티티를 저장하는 save() 메서드 호출 전에 id값이 명시되어 있어야 한다는 오류이다.</description>
    </item>
    
    <item>
      <title>자주 사용하는 git 명령어 모음</title>
      <link>https://parker1609.github.io/post/cheat-sheet-git-commands/</link>
      <pubDate>Sun, 27 Jun 2021 10:14:10 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/cheat-sheet-git-commands/</guid>
      <description>Git 쓰면서 겪었던 상황과 이를 해결한 명령어 모음입니다.
Git Command Help 터미널 환경에서 GIT을 사용할 경우 명령어로 쉽게 git command 정보를 알 수 있다. 바로 --help 옵션을 사용하는 것이다.
Git add 명령어 정보 보기
git add --help Git checkout 명령어 정보 보기
git checkout --help Git Branch Local Branch 이름 변경하기 git branch -m &amp;lt;변경 전 branch name&amp;gt; &amp;lt;변경 후 branch name&amp;gt; Local Branch 삭제하기 git branch -D &amp;lt;local branch name&amp;gt; Remote Branch 참고하기 Remote branch를 수정하지 않고 단지 읽고만 싶은 경우</description>
    </item>
    
    <item>
      <title>[IntelliJ IDEA] 유용한 플러그인 모음</title>
      <link>https://parker1609.github.io/post/intellij-idea-useful-plugin/</link>
      <pubDate>Sat, 26 Jun 2021 10:41:49 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/intellij-idea-useful-plugin/</guid>
      <description> 참고로, 최신 인텔리제이를 다운로드 받아보면 예전에는 직접 다운로드 받아야했던 플러그인들이 기본적으로 포함되어 있는 경우도 있었다.
IdeaVim 플러그인 홈페이지 Vim 환경을 인텔리제이에서 사용하고 싶을 때 사용하기 Rainbow Brackets 플러그인 홈페이지 코드 특성상 괄호의 종류와 중첩을 매우 자주 볼 수 있다. 이를 색깔로 편하게 구분할 수 있도록 도와준다. One Dark Theme 플러그인 홈페이지 Material Theme UI와 One Dark Theme 두 테마가 가장 인기가 좋은 듯 하다. CodeGlance 플러그인 홈페이지 코드의 전체 모습을 미리볼 수 있는 플러그인 Nyan Progress Bar 플러그인 홈페이지 밋밋한 진행바(progress bar)를 귀여운 고양이로 만들어주는 힐링 플러그인 오로지 귀여운 고양이를 보기 위한 플러그인&amp;hellip; </description>
    </item>
    
    <item>
      <title>Call by Value vs Call by Reference</title>
      <link>https://parker1609.github.io/post/call-by-value-vs-call-by-reference/</link>
      <pubDate>Wed, 04 Mar 2020 13:40:05 +0900</pubDate>
      
      <guid>https://parker1609.github.io/post/call-by-value-vs-call-by-reference/</guid>
      <description>C++과 Java를 공부하면서 헷갈렸던 것 중 하나가 call by value와 call by reference입니다. 흔히 Java가 call by reference가 가능한지에 대해 의견이 분분한 것을 보았습니다. 저도 이부분이 헷갈리기 시작하여 두 언어의 차이점에 대해 생각하며 결론을 내보았습니다. 이는 주관적인 생각이 포함되어 있으므로 의견이 다르거나 틀린 점이 있다면 지적 부탁드립니다!
먼저 결론부터 말씀드리면, Java는 call by reference를 할 수 없다고 생각합니다. 이에 대한 근거는 call by value부터 차근차근 살펴보면서 말씀드리겠습니다.
Call By Value Call by value는 원본 값을 그대로 복사하여 매개변수로 전달하는 것입니다.</description>
    </item>
    
  </channel>
</rss>
