<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴 | Parker Blog</title><meta name=keywords content="Design Pattern,Template Method Pattern,Strategy Pattern,Template Callback Pattern,Java"><meta name=description content="이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.
패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.
전체 예제 코드는 이 링크에서 볼 수 있습니다.
예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다."><meta name=author content="parker1609"><link rel=canonical href=https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.6a98292fb8fa8cf0f3ba4042d4b75515c04267550f3ad49ff6271b5af9562443.css integrity="sha256-apgpL7j6jPDzukBC1LdVFcBCZ1UPOtSf9icbWvlWJEM=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://parker1609.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴"><meta property="og:description" content="이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.
패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.
전체 예제 코드는 이 링크에서 볼 수 있습니다.
예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다."><meta property="og:type" content="article"><meta property="og:url" content="https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/"><meta property="og:image" content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="post"><meta property="article:published_time" content="2023-04-01T10:47:30+09:00"><meta property="article:modified_time" content="2023-04-01T10:47:30+09:00"><meta property="og:site_name" content="Parker Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://parker1609.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴"><meta name=twitter:description content="이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.
패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.
전체 예제 코드는 이 링크에서 볼 수 있습니다.
예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://parker1609.github.io/post/"},{"@type":"ListItem","position":2,"name":"[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴","item":"https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴","name":"[디자인 패턴] 템플릿 메서드 패턴\/전략 패턴\/템플릿 콜백 패턴","description":"이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.\n패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.\n전체 예제 코드는 이 링크에서 볼 수 있습니다.\n예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다.","keywords":["Design Pattern","Template Method Pattern","Strategy Pattern","Template Callback Pattern","Java"],"articleBody":"이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다. 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다. 이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다. 여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.\n패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.\n전체 예제 코드는 이 링크에서 볼 수 있습니다.\n예제 - 문자 알림 전송 기능 개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다. 이 기능의 요구사항은 다음과 같았다.\n문자 전송은 A 외부 서비스 API를 사용한다. API 요청 정보는 휴대폰 번호와 문자 내용 두 가지가 존재한다. 응답은 문자 발송에 성공하면 true, 문자 발송에 실패하면 false를 반환한다. 문자 전송 전후로 시작과 결과 로그를 남긴다. 결과 로그에는 외부 서비스 API의 요청에서 응답까지 소요된 시간을 측정한 결과를 보여줘야한다. 작업을 맡은 파커는 빠르게 개발하여 아래의 코드를 작성하였고, 배포하였다.\npublic void sendSms(String cellphoneNumber, String smsContents) { log.info(\"문자 발송 시작\");\tlong startTime = System.currentTimeMillis(); ASmsSendingService aService = new ASmsSendingService(); // 중간 로직 생략... boolean result = aService.send(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } 시간이 지나고 서비스가 성장하면서 문자 알림 전송의 양도 크게 증가하였다. 그 결과, A 문자 서비스를 사용하는 비용이 너무 부담스러워졌다. 이 비용을 줄이기 위해 가격이 더 저렴한 B 문자 서비스로 변경해달라는 요청이 왔다.\npublic void sendSms(String cellphoneNumber, String smsContents) { log.info(\"문자 발송 시작\");\tlong startTime = System.currentTimeMillis(); BSmsSendingService bService = new BSmsSendingService(); // 중간 로직 생략... boolean result = bService.send(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } 개발자 파커는 B 문자 서비스를 사용하기 위해 내부 로직을 모두 바꾸고 테스트 후 배포하였다. 한시름 돌린 찰라에 개발 환경을 분리한다는 이야기가 나왔고, 운영 환경이 아닌 개발 환경에서는 문자를 보내면 안된다는 요구사항이 생겼다.\n파커는 고민에 빠졌다. sendSms() 메서드가 외부 서비스가 변경될 때마다 수정이 되어야 하는지 의문이었다. 그리고 외부 서비스를 변경하는 코드 외에 로그를 출력하는 것과 시간을 측정하는 부분은 변하지 않는데, sendSms() 메서드가 계속 변경되는 것도 마음에 들지 않았다.\n문자 외부 서비스가 변경되거나 심지어 실제로는 보내지 않게 하는 로직으로 변경되어도 sendSms() 메서드에는 전혀 변경이 일어나지 않게 하려면 어떻게 해야 할까? 객체지향의 원칙 중 SRP 관점에서도 sendSms() 메서드는 문자 외부 서비스 사용에 대한 역할과 문자 전송의 진행과정을 로그로 남겨야하는 두 가지 역할로 인해서 변경되는 이유가 2 가지 이상이 되어버린다. 이는 객체지향적이지 않은 코드로 보인다.\n이를 해결하기위해 처음에 언급한 디자인 패턴을 적용해보며, 문자 외부 서비스가 바뀌어도 어떻게 변경없이 sendSms() 메서드를 재사용할 수 있는지 살펴보자.\n템플릿 메서드 패턴(Template Method Pattern) 먼저, 템플릿 메서드 패턴이 무엇인지 알아보자. GOF 디자인 패턴 책에서는 다음과 같이 정의하고 있다.\nDefines the skeleton of an algorithm in a method, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithms structure. - GOF -\n위 그림과 함께 설명하면, 부모 클래스는 어떠한 기능(알고리즘)의 템플릿을 정의하고, templateMethod() (변경되는 로직)는 자식 클래스에서 재정의한다. 이는 객체지향의 특징인 상속과 다형성을 통해 변경되는 부분을 관리하는 것이다.\n위 예제에서 변경되는 부분은 문자 외부 서비스 API를 호출하는 부분이다.\nASmsSendingService aService = new ASmsSendingService(); // ... boolean result = aService.send(cellphoneNumber, smsContents); BSmsSendingService bService = new BSmsSendingService(); // ... boolean result = bService.send(cellphoneNumber, smsContents); 위 두 코드를 보면 요구사항이 변경되었을 때 sendSms() 메서드가 변경된 부분을 비교한 모습이다. 이 부분을 위 그림에서 templateMethod() 로 분리한다면, 어떤 외부 서비스가 오더라도 sendSms() 메서드 자체는 변경될 일이 없을 것이다.\n@Slf4j public abstract class SmsTemplateService { public void sendSms(String cellphoneNumber, String smsContents) { log.info(\"문자 발송 시작\"); long startTime = System.currentTimeMillis(); boolean result = requestAPI(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } public abstract boolean requestAPI(String cellphoneNumber, String smsContents); } 먼저, 그림의 Abstratct Class 부분인 부모 클래스를 보자. 변경되는 부분인 templateMethod() 가 requestAPI() 메서드이다. 이는 자식 클래스에서 재정의해야 한다. A 외부 서비스와 B 외부 서비스를 사용하는 자식클래스는 다음과 같이 구현할 수 있다.\npublic class ASmsService extends SmsTemplateService { @Override public boolean requestAPI(String cellphoneNumber, String smsContents) { ASmsSendingService aService = new ASmsSendingService(); return aService.send(cellphoneNumber, smsContents); } } public class BSmsService extends SmsTemplateService { @Override public boolean requestAPI(String cellphoneNumber, String smsContents) { BSmsSendingService bService = new BSmsSendingService(); return bService.send(cellphoneNumber, smsContents); } } 이를 사용하는 클라이언트를 간단히 테스트 코드로 작성해보면 다음과 같다.\n@Test void send_sms_using_a_service() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello!\"; SmsTemplateService service = new ASmsService(); service.sendSms(cellphoneNumber, smsContents); } A 문자 서비스를 사용하기 위해서 구체 클래스는 ASmsService 로 생성하였다. 문자 발송 시작 A 외부 서비스 사용: [010-1111-2222]에게 'Hello!' 내용 문자 보내기 문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms @Test void send_sms_using_b_service() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello!\"; SmsTemplateService service = new BSmsService(); service.sendSms(cellphoneNumber, smsContents); } 문자 발송 시작 B 외부 서비스 사용: [010-1111-2222]에게 'Hello!' 내용 문자 보내기 문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms 템플릿 메서드 패턴의 단점은 상속을 사용한다는 점이다. 상속을 사용하게 되면, 자식 클래스들은 부모 클래스에게 강하게 결합된다. 위 코드는 부모 클래스에 로직이나 필드가 없지만, 이러한 코드들이 추가되면 자식 클래스도 이를 똑같이 가져가게 된다. 만약 부모 클래스가 변경된다면 자식 클래스 모두를 변경해야 되는 상황도 올 수 있다.\n(그 외 단점인 코드양이 많아지고 구조가 복잡해지는 것은 디자인 패턴을 사용할 때 공통적인 단점이다. 사실 변경에 유연한 코드를 위해서 이러한 단점은 불가피한 상황이다. 따라서 간단하고 변경이 될 여지가 거의 없는 코드라면 디자인 패턴을 사용하지 않는 것이 더 좋을 때도 있다.)\n이러한 상속에 대한 단점을 없애고, 템플릿 메서드 패턴과 유사한 장점을 가질 수 있는 패턴이 전략 패턴이다.\n전략 패턴(Strategy Pattern) 전략 패턴은 GOF에서 다음과 같이 정의한다.\nDefine a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it - GOF -\n전략 패턴은 말그대로 여러 전략을 쉽게 교환할 수 있도록 만드는 패턴이다. 템플릿 메서드 패턴은 변경되는 부분을 부모 클래스의 추상 메서드(템플릿 메서드)로 만들었지만, 전략 패턴은 이를 인터페이스로 완전히 분리하였다. 그리고 변경되지 않는 부분은 Context에 존재한다.\n먼저, Context에 해당하는 코드를 보자.\n@Slf4j public class SmsService { private final SmsSendingStrategy smsSendingStrategy; public SmsService(SmsSendingStrategy smsSendingStrategy) { this.smsSendingStrategy = smsSendingStrategy; } public void sendSms(String cellphoneNumber, String smsContents) { log.info(\"문자 발송 시작\"); long startTime = System.currentTimeMillis(); boolean result = smsSendingStrategy.execute(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } } sendSms() 메서드가 존재하는 클래스 SmsService가 Context에 해당하는 클래스이다. 여기서는 전략을 필드에 위치시켰다. 전략에 해당하는 인터페이스는 다음과 같다.\npublic interface SmsSendingStrategy { boolean execute(String cellphoneNumber, String smsContents); } Context는 전략에 해당하는 인터페이스에만 의존하고 있고, 이 전략이 변경된다고 해서 Context는 전혀 변경되지 않는다.\n구체적인 전략은 이 전략 인터페이스를 구현하는 클래스로 선언할 수 있다.\n@Slf4j public class SmsSendingStrategyA implements SmsSendingStrategy { @Override public boolean execute(String cellphoneNumber, String smsContents) { log.info(\"A 외부 서비스 사용: [{}]에게 '{}' 내용 문자 보내기\", cellphoneNumber, smsContents); return true; } } 이를 사용하는 클라이언트는 다음과 같이 선언할 수 있다.\n@Test void send_sms_using_a_service() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello! Strategy Pattern.\"; SmsSendingStrategy strategyA = new SmsSendingStrategyA(); SmsService service = new SmsService(strategyA); service.sendSms(cellphoneNumber, smsContents); } 문자 발송 시작 A 외부 서비스 사용: [010-1111-2222]에게 'Hello! Strategy Pattern.' 내용 문자 보내기 문자 발송 결과: 성공 여부 = true, 소요 시간 = 2ms 여기서, 전략 패턴 구현 방식에 대해 몇 가지 추가적으로 살펴볼 것이 있다. 먼저 전략의 위치에 대해 살펴보자. 위는 전략을 Context의 필드에 선언하여, Context 클래스가 생성될 때 초기화되도록 하였다. 이를 ‘선 조립, 후 실행’ 이라고도 부르는데, 이는 필요한 전략이 실행 시점에 반드시 존재한다는 것을 보장받을 수 있다. 스프링 프레임워크가 실행 시점에 모든 빈 의존관계를 설정하는 것과 같은 이치이다. 하지만 단점으로는 전략을 변경하는데 드는 비용이 크다는 점이다. 전략을 바꾸기 위해서는 Context 객체를 새로 생성해야 하기 때문이다.\n위 단점을 해결하기 위해서는 전략의 위치를 변경해줄 수 있다. Context의 필드가 아닌, 실제로 사용하는 메서드의 매개변수로 받을 수 있다.\n@Slf4j public class SmsService { public void sendSms(String cellphoneNumber, String smsContents, SmsSendingStrategy smsSendingStrategy) { log.info(\"문자 발송 시작\"); long startTime = System.currentTimeMillis(); boolean result = smsSendingStrategy.execute(cellphoneNumber, smsContents); long endTime = System.currentTimeMillis(); long resultTime = endTime - startTime; log.info(\"문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms\", result, resultTime); } } 위 Context 클래스는 전략 인터페이스를 필드가 아닌 실제 사용하는 sendSms() 메서드의 매개변수로 받고 있다. 이렇게 구현하면, ‘선 조립, 후 실행’에서의 단점은 해결할 수 있지만, 실행 시점에 이 전략이 존재하는지에 대해서 보장받을 수는 없다.\n전략 위치를 어디에 둘 지는 답이 없고 서로 장단점이 명확히 구분된다. 따라서 상황에 따라 선택해서 사용하는 것을 권장한다.\n한 가지 떠 살펴볼 점은 전략을 구현하는 방식이다. 전략 인터페이스의 구현체를 꼭 클래스 파일로 만들 필요가 있을까? 한 전략의 구현체가 여러 곳에서 사용하는 것이 아닌 딱 한 곳에서만 필요한 경우라면 클래스 파일로 따로 분리해서 선언하는 것보다 익명 클래스 또는 람다를 사용해서도 구현할 수 있다.\n클라이언트에서 전략 구현체를 직접 구현해서 사용하는 코드를 보자.\n@Test void send_sms_using_a_service_anonymous_class() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello! Strategy Pattern.\"; SmsService service = new SmsService(new SmsSendingStrategy() { @Override public boolean execute(String cellphoneNumber, String smsContents) { log.info(\"A 외부 서비스 사용: [{}]에게 '{}' 내용 문자 보내기\", cellphoneNumber, smsContents); return true; } }); service.sendSms(cellphoneNumber, smsContents); } 익명 클래스를 사용하면 위와 같이 구현할 수 있다. 여기에 Java8 이상 버전을 사용하고, 전략 인터페이스가 FuntionalInterface라면, 람다 표현식으로 더욱 깔끔하게 구현할 수도 있다.\n@Test void send_sms_using_a_service_lambda() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello! Strategy Pattern.\"; SmsService service = new SmsService((cellphoneNumber1, smsContents1) -\u003e { log.info(\"A 외부 서비스 사용: [{}]에게 '{}' 내용 문자 보내기\", cellphoneNumber1, smsContents1); return true; }); service.sendSms(cellphoneNumber, smsContents); } 지금까지는 전략 패턴을 살펴봤다. 템플릿 메서드 패턴에 비해서 상속을 사용하지 않고 인터페이스를 사용하므로, 좀 더 코드를 유연하게 사용할 수 있다. 전략은 더이상 Context(또는 템플릿)에 의존하지 않으므로 자유롭게 필요에 따라 구체적인 전략을 만들고, 또는 새로운 전략 인터페이스를 사용할 수도 있다.\n템플릿 콜백 패턴(Template Callback Pattern) 마지막으로, 템플릿 콜백 패턴을 살펴보자. 템플릿 콜백 패턴은 사실 전략 패턴을 몇 가지 방식으로 구현하면서 이미 사용되었다. 전략 패턴의 전략이 콜백으로 변경된 것 뿐이다\n프로그래밍에서 콜백(callback) 또는 콜애프터 함수(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다. - 위키백과 -\n정리하면 콜백 코드는 호출(call)한 곳에서 실행되지 않고, 호출을 요청한 곳(back or callee)에서 실행되는 코드를 말한다.\n이 패턴은 GOF에서 나온 패턴이 아닌, 스프링 프레임워크에서 부르는 패턴이다. 토비의 스프링 책에서 그림을 보면 좀 더 이해하기 쉬울 듯 하다. (토비 스프링 책을 참고하여 예제에 맞게 살짝 수정하였다.)\n위 그림처럼 동작하려면 콜백 코드를 템플릿 메서드에게 넘기는 방법이 필요하다. 자바 8부터는 이러한 코드를 람다 형태로 매개변수로 전달할 수 있다. (자바 8 이전에는 익명 클래스 사용)\n위 그림을 자세히 보면 앞서 전략 패턴을 구현하던 방식 중 람다를 사용한 흐름과 같다.\n@Test void send_sms_using_a_service_lambda() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello! Strategy Pattern.\"; SmsService service = new SmsService((cellphoneNumber1, smsContents1) -\u003e { log.info(\"A 외부 서비스 사용: [{}]에게 '{}' 내용 문자 보내기\", cellphoneNumber1, smsContents1); return true; }); service.sendSms(cellphoneNumber, smsContents); } 람다를 사용한 전략패턴을 다시 한 번 보자. 사실 살짝 다른 지점이 보인다. 위는 전략을 필드로 삽입하여, 그림과 매칭하기가 조금 헷갈릴 수가 있다. 전략의 위치를 매개변수로 바꾸고 이를 람다로 하면 완전히 위 그림과 같아질 것이다.\n@Test void send_sms_using_a_service_lambda() { String cellphoneNumber = \"010-1111-2222\"; String smsContents = \"Hello! Strategy Pattern.\"; SmsService service = new SmsService(); service.sendSms(cellphoneNumber, smsContents, (cellphoneNumber1, smsContents1) -\u003e { log.info(\"A 외부 서비스 사용: [{}]에게 '{}' 내용 문자 보내기\", cellphoneNumber1, smsContents1); return true; }); } 위 코드를 보자. sendSms() 메서드의 매개변수로 람다식을 사용했고, 이 코드가 콜백 코드이다. 그림과 매칭해보면, 클라이언트는 테스트 코드 메서드이고, 콜백은 매개변수의 람다식이다. 그리고 템플릿은 sendSms() 메서드이다.\n이를 보면 템플릿 콜백 패턴은 전략 패턴의 용어 중 일부만 살짝 바꾸면 바로 같아진다.\nStrategy Pattern → Template Callback Pattern Strategy → Callback Context → Template 정리 지금까지 문자 전송 기능 예제를 통해 디자인 패턴 중 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴 이렇게 3가지를 살펴보았다. 이 3 가지 디자인 패턴의 의도는 같다. 변경되기 쉬운 코드와 그렇지 않은 코드를 분리하고, 변경되기 쉬운 코드를 추상 메서드 또는 인터페이스로 추상화하여 변경 지점을 추출하였다. 그 결과, 변경을 하더라도 템플릿(또는 컨텍스트) 코드는 그대로이고 이를 어디서든 재사용 및 확장할 수 있게 되었다.\n이는 객체지향 5대 원칙 중에서도 OCP를 만족시키는 대표적인 사례이다. 템플릿(또는 컨텍스트) 코드 기준으로 확장에는 열려있지만, 변경에는 닫혀있다. (사실, 패턴에 더해서 클라이언트라는 제 3자의 위치에서 구체 클래스의 주입까지 더해져서 OCP가 온전히 완성되었음을 인지하고 있어야 한다.)\n참고자료 인프런 강의 - [스프링 핵심 원리 - 고급편] GoF의 디자인 패턴 토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리 ","wordCount":"2003","inLanguage":"en","datePublished":"2023-04-01T10:47:30+09:00","dateModified":"2023-04-01T10:47:30+09:00","author":{"@type":"Person","name":"parker1609"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://parker1609.github.io/post/design-pattern-template-method-pattern-and-strategy-pattern-andt-template-callback-pattern/"},"publisher":{"@type":"Organization","name":"Parker Blog","logo":{"@type":"ImageObject","url":"https://parker1609.github.io/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://parker1609.github.io/ accesskey=h title="파커 블로그 (Alt + H)"><img src=https://parker1609.github.io/apple-touch-icon.png alt aria-label=logo height=35>파커 블로그</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://parker1609.github.io/archives/ title=Archives><span>Archives</span></a></li><li><a href=https://parker1609.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://parker1609.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://parker1609.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://parker1609.github.io/post/>Posts</a></div><h1 class=post-title>[디자인 패턴] 템플릿 메서드 패턴/전략 패턴/템플릿 콜백 패턴</h1><div class=post-meta><span title='2023-04-01 10:47:30 +0900 KST'>April 1, 2023</span>&nbsp;·&nbsp;parker1609</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%ec%98%88%ec%a0%9c---%eb%ac%b8%ec%9e%90-%ec%95%8c%eb%a6%bc-%ec%a0%84%ec%86%a1-%ea%b8%b0%eb%8a%a5 aria-label="예제 - 문자 알림 전송 기능">예제 - 문자 알림 전송 기능</a></li><li><a href=#%ed%85%9c%ed%94%8c%eb%a6%bf-%eb%a9%94%ec%84%9c%eb%93%9c-%ed%8c%a8%ed%84%b4template-method-pattern aria-label="템플릿 메서드 패턴(Template Method Pattern)">템플릿 메서드 패턴(Template Method Pattern)</a></li><li><a href=#%ec%a0%84%eb%9e%b5-%ed%8c%a8%ed%84%b4strategy-pattern aria-label="전략 패턴(Strategy Pattern)">전략 패턴(Strategy Pattern)</a></li><li><a href=#%ed%85%9c%ed%94%8c%eb%a6%bf-%ec%bd%9c%eb%b0%b1-%ed%8c%a8%ed%84%b4template-callback-pattern aria-label="템플릿 콜백 패턴(Template Callback Pattern)">템플릿 콜백 패턴(Template Callback Pattern)</a></li><li><a href=#%ec%a0%95%eb%a6%ac aria-label=정리>정리</a></li><li><a href=#%ec%b0%b8%ea%b3%a0%ec%9e%90%eb%a3%8c aria-label=참고자료>참고자료</a></li></ul></div></details></div><div class=post-content><p>이 글은 GOF 중에서 의도가 거의 유사하지만, 구현 방식이 조금씩 다른 3 가지 패턴을 알아본다.
템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴이다.
이 3가지 패턴은 변경이 자주 발생하는 코드와 그렇지 않은 코드를 분리하는 것이 핵심이다.
여기에 객체지향의 다형성(또는 상속)을 이용하여 변경이 자주 발생하는 코드를 유연하게 대처하도록 한다.</p><p>패턴을 설명하기 위해 한 가지 예제를 바탕으로 각각의 패턴이 어떻게 구현되는지 살펴보자.</p><blockquote><p>전체 예제 코드는 이 <a href=https://github.com/parker1609/my-articles/tree/main/Java/design-pattern>링크</a>에서 볼 수 있습니다.</p></blockquote><h1 id=예제---문자-알림-전송-기능>예제 - 문자 알림 전송 기능<a hidden class=anchor aria-hidden=true href=#예제---문자-알림-전송-기능>#</a></h1><p>개발자 파커는 애플리케이션에 문자 알림을 전송하는 기능을 추가하는 작업을 맡게 되었다.
이 기능의 요구사항은 다음과 같았다.</p><ul><li>문자 전송은 A 외부 서비스 API를 사용한다.<ul><li>API 요청 정보는 휴대폰 번호와 문자 내용 두 가지가 존재한다.</li><li>응답은 문자 발송에 성공하면 true, 문자 발송에 실패하면 false를 반환한다.</li></ul></li><li>문자 전송 전후로 시작과 결과 로그를 남긴다.</li><li>결과 로그에는 외부 서비스 API의 요청에서 응답까지 소요된 시간을 측정한 결과를 보여줘야한다.</li></ul><p>작업을 맡은 파커는 빠르게 개발하여 아래의 코드를 작성하였고, 배포하였다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>	
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>ASmsSendingService</span> <span class=n>aService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ASmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 중간 로직 생략...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>aService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>시간이 지나고 서비스가 성장하면서 문자 알림 전송의 양도 크게 증가하였다.
그 결과, A 문자 서비스를 사용하는 비용이 너무 부담스러워졌다.
이 비용을 줄이기 위해 가격이 더 저렴한 B 문자 서비스로 변경해달라는 요청이 왔다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>	<span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>	
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=n>BSmsSendingService</span> <span class=n>bService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BSmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 중간 로직 생략...
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>bService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>	<span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>	<span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>개발자 파커는 B 문자 서비스를 사용하기 위해 내부 로직을 모두 바꾸고 테스트 후 배포하였다.
한시름 돌린 찰라에 개발 환경을 분리한다는 이야기가 나왔고, 운영 환경이 아닌 개발 환경에서는 문자를 보내면 안된다는 요구사항이 생겼다.</p><p>파커는 고민에 빠졌다.
<code>sendSms()</code> 메서드가 외부 서비스가 변경될 때마다 수정이 되어야 하는지 의문이었다.
그리고 외부 서비스를 변경하는 코드 외에 로그를 출력하는 것과 시간을 측정하는 부분은 변하지 않는데,
<code>sendSms()</code> 메서드가 계속 변경되는 것도 마음에 들지 않았다.</p><p>문자 외부 서비스가 변경되거나 심지어 실제로는 보내지 않게 하는 로직으로 변경되어도
<code>sendSms()</code> 메서드에는 전혀 변경이 일어나지 않게 하려면 어떻게 해야 할까?
객체지향의 원칙 중 SRP 관점에서도 <code>sendSms()</code> 메서드는 문자 외부 서비스 사용에 대한 역할과
문자 전송의 진행과정을 로그로 남겨야하는 두 가지 역할로 인해서 변경되는 이유가 2 가지 이상이 되어버린다.
이는 객체지향적이지 않은 코드로 보인다.</p><p>이를 해결하기위해 처음에 언급한 디자인 패턴을 적용해보며, 문자 외부 서비스가 바뀌어도 어떻게 변경없이
<code>sendSms()</code> 메서드를 재사용할 수 있는지 살펴보자.</p><h1 id=템플릿-메서드-패턴template-method-pattern>템플릿 메서드 패턴(Template Method Pattern)<a hidden class=anchor aria-hidden=true href=#템플릿-메서드-패턴template-method-pattern>#</a></h1><p>먼저, 템플릿 메서드 패턴이 무엇인지 알아보자. GOF 디자인 패턴 책에서는 다음과 같이 정의하고 있다.</p><blockquote><p>Defines the skeleton of an algorithm in a method, deferring some steps to subclasses.
Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithms structure. - GOF -</p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229260218-ee3050c5-f155-4d90-ba44-3886d9a0017f.png alt="Template Method Pattern"></p><p>위 그림과 함께 설명하면, 부모 클래스는 어떠한 기능(알고리즘)의 템플릿을 정의하고,
<code>templateMethod()</code> (변경되는 로직)는 자식 클래스에서 재정의한다.
이는 객체지향의 특징인 상속과 다형성을 통해 변경되는 부분을 관리하는 것이다.</p><p>위 예제에서 변경되는 부분은 문자 외부 서비스 API를 호출하는 부분이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>ASmsSendingService</span> <span class=n>aService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ASmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>aService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=n>BSmsSendingService</span> <span class=n>bService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BSmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl><span class=c1>// ...
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>bService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span></code></pre></div><p>위 두 코드를 보면 요구사항이 변경되었을 때 <code>sendSms()</code> 메서드가 변경된 부분을 비교한 모습이다.
이 부분을 위 그림에서 <code>templateMethod()</code> 로 분리한다면, 어떤 외부 서비스가 오더라도
<code>sendSms()</code> 메서드 자체는 변경될 일이 없을 것이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>abstract</span> <span class=kd>class</span> <span class=nc>SmsTemplateService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>requestAPI</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kd>abstract</span> <span class=kt>boolean</span> <span class=nf>requestAPI</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>먼저, 그림의 Abstratct Class 부분인 부모 클래스를 보자. 변경되는 부분인 <code>templateMethod()</code> 가
<code>requestAPI()</code> 메서드이다. 이는 자식 클래스에서 재정의해야 한다.
A 외부 서비스와 B 외부 서비스를 사용하는 자식클래스는 다음과 같이 구현할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>ASmsService</span> <span class=kd>extends</span> <span class=n>SmsTemplateService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>requestAPI</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>ASmsSendingService</span> <span class=n>aService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ASmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>aService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>BSmsService</span> <span class=kd>extends</span> <span class=n>SmsTemplateService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>requestAPI</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>BSmsSendingService</span> <span class=n>bService</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BSmsSendingService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=n>bService</span><span class=o>.</span><span class=na>send</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>이를 사용하는 클라이언트를 간단히 테스트 코드로 작성해보면 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello!&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsTemplateService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>ASmsService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><ul><li>A 문자 서비스를 사용하기 위해서 구체 클래스는 <code>ASmsService</code> 로 생성하였다.</li></ul><pre tabindex=0><code>문자 발송 시작
A 외부 서비스 사용: [010-1111-2222]에게 &#39;Hello!&#39; 내용 문자 보내기
문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms
</code></pre><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_b_service</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello!&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsTemplateService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BSmsService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><pre tabindex=0><code>문자 발송 시작
B 외부 서비스 사용: [010-1111-2222]에게 &#39;Hello!&#39; 내용 문자 보내기
문자 발송 결과: 성공 여부 = true, 소요 시간 = 1ms
</code></pre><p>템플릿 메서드 패턴의 단점은 상속을 사용한다는 점이다. 상속을 사용하게 되면, 자식 클래스들은 부모 클래스에게 강하게 결합된다.
위 코드는 부모 클래스에 로직이나 필드가 없지만, 이러한 코드들이 추가되면 자식 클래스도 이를 똑같이 가져가게 된다.
만약 부모 클래스가 변경된다면 자식 클래스 모두를 변경해야 되는 상황도 올 수 있다.</p><p>(그 외 단점인 코드양이 많아지고 구조가 복잡해지는 것은 디자인 패턴을 사용할 때 공통적인 단점이다.
사실 변경에 유연한 코드를 위해서 이러한 단점은 불가피한 상황이다.
따라서 간단하고 변경이 될 여지가 거의 없는 코드라면 디자인 패턴을 사용하지 않는 것이 더 좋을 때도 있다.)</p><p>이러한 상속에 대한 단점을 없애고, 템플릿 메서드 패턴과 유사한 장점을 가질 수 있는 패턴이 전략 패턴이다.</p><h1 id=전략-패턴strategy-pattern>전략 패턴(Strategy Pattern)<a hidden class=anchor aria-hidden=true href=#전략-패턴strategy-pattern>#</a></h1><p>전략 패턴은 GOF에서 다음과 같이 정의한다.</p><blockquote><p><em>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it - GOF -</em></p></blockquote><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229260320-25566327-c147-46ae-9713-94ad5287ab28.png alt="Strategy Pattern"></p><p>전략 패턴은 말그대로 여러 전략을 쉽게 교환할 수 있도록 만드는 패턴이다. 템플릿 메서드 패턴은 변경되는 부분을 부모 클래스의 추상 메서드(템플릿 메서드)로 만들었지만, 전략 패턴은 이를 인터페이스로 완전히 분리하였다. 그리고 변경되지 않는 부분은 Context에 존재한다.</p><p>먼저, Context에 해당하는 코드를 보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SmsService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>private</span> <span class=kd>final</span> <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=nf>SmsService</span><span class=o>(</span><span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>this</span><span class=o>.</span><span class=na>smsSendingStrategy</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p><code>sendSms()</code> 메서드가 존재하는 클래스 SmsService가 Context에 해당하는 클래스이다. 여기서는 전략을 필드에 위치시켰다. 전략에 해당하는 인터페이스는 다음과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=kd>public</span> <span class=kd>interface</span> <span class=nc>SmsSendingStrategy</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=kt>boolean</span> <span class=nf>execute</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>Context는 전략에 해당하는 인터페이스에만 의존하고 있고, 이 <strong>전략이 변경된다고 해서 Context는 전혀 변경되지 않는다.</strong></p><p>구체적인 전략은 이 전략 인터페이스를 구현하는 클래스로 선언할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SmsSendingStrategyA</span> <span class=kd>implements</span> <span class=n>SmsSendingStrategy</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>execute</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;A 외부 서비스 사용: [{}]에게 &#39;{}&#39; 내용 문자 보내기&#34;</span><span class=o>,</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>이를 사용하는 클라이언트는 다음과 같이 선언할 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello! Strategy Pattern.&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsSendingStrategy</span> <span class=n>strategyA</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsSendingStrategyA</span><span class=o>();</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>(</span><span class=n>strategyA</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=err>문자</span> <span class=err>발송</span> <span class=err>시작</span>
</span></span><span class=line><span class=cl><span class=n>A</span> <span class=err>외부</span> <span class=err>서비스</span> <span class=err>사용</span><span class=o>:</span> <span class=o>[</span><span class=mo>010</span><span class=o>-</span><span class=mi>1111</span><span class=o>-</span><span class=mi>2222</span><span class=o>]</span><span class=err>에게</span> <span class=err>&#39;</span><span class=n>Hello</span><span class=o>!</span> <span class=n>Strategy</span> <span class=n>Pattern</span><span class=o>.</span><span class=err>&#39;</span> <span class=err>내용</span> <span class=err>문자</span> <span class=err>보내기</span>
</span></span><span class=line><span class=cl><span class=err>문자</span> <span class=err>발송</span> <span class=err>결과</span><span class=o>:</span> <span class=err>성공</span> <span class=err>여부</span> <span class=o>=</span> <span class=kc>true</span><span class=o>,</span> <span class=err>소요</span> <span class=err>시간</span> <span class=o>=</span> <span class=mi>2</span><span class=n>ms</span>
</span></span></code></pre></div><p>여기서, 전략 패턴 구현 방식에 대해 몇 가지 추가적으로 살펴볼 것이 있다. 먼저 전략의 위치에 대해 살펴보자. 위는 전략을 Context의 필드에 선언하여, Context 클래스가 생성될 때 초기화되도록 하였다. 이를 ‘선 조립, 후 실행&rsquo; 이라고도 부르는데, 이는 필요한 전략이 실행 시점에 반드시 존재한다는 것을 보장받을 수 있다. 스프링 프레임워크가 실행 시점에 모든 빈 의존관계를 설정하는 것과 같은 이치이다. 하지만 단점으로는 전략을 변경하는데 드는 비용이 크다는 점이다. 전략을 바꾸기 위해서는 Context 객체를 새로 생성해야 하기 때문이다.</p><p>위 단점을 해결하기 위해서는 전략의 위치를 변경해줄 수 있다. Context의 필드가 아닌, 실제로 사용하는 메서드의 매개변수로 받을 수 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Slf4j</span>
</span></span><span class=line><span class=cl><span class=kd>public</span> <span class=kd>class</span> <span class=nc>SmsService</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>public</span> <span class=kt>void</span> <span class=nf>sendSms</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>,</span>
</span></span><span class=line><span class=cl>                        <span class=n>SmsSendingStrategy</span> <span class=n>smsSendingStrategy</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 시작&#34;</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>startTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>boolean</span> <span class=n>result</span> <span class=o>=</span> <span class=n>smsSendingStrategy</span><span class=o>.</span><span class=na>execute</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>endTime</span> <span class=o>=</span> <span class=n>System</span><span class=o>.</span><span class=na>currentTimeMillis</span><span class=o>();</span>
</span></span><span class=line><span class=cl>        <span class=kt>long</span> <span class=n>resultTime</span> <span class=o>=</span> <span class=n>endTime</span> <span class=o>-</span> <span class=n>startTime</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;문자 발송 결과: 성공 여부 = {}, 소요 시간 = {}ms&#34;</span><span class=o>,</span> <span class=n>result</span><span class=o>,</span> <span class=n>resultTime</span><span class=o>);</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>위 Context 클래스는 전략 인터페이스를 필드가 아닌 실제 사용하는 <code>sendSms()</code> 메서드의 매개변수로 받고 있다. 이렇게 구현하면, ‘선 조립, 후 실행&rsquo;에서의 단점은 해결할 수 있지만, 실행 시점에 이 전략이 존재하는지에 대해서 보장받을 수는 없다.</p><p>전략 위치를 어디에 둘 지는 답이 없고 서로 장단점이 명확히 구분된다. 따라서 상황에 따라 선택해서 사용하는 것을 권장한다.</p><p>한 가지 떠 살펴볼 점은 전략을 구현하는 방식이다. 전략 인터페이스의 구현체를 꼭 클래스 파일로 만들 필요가 있을까? 한 전략의 구현체가 여러 곳에서 사용하는 것이 아닌 딱 한 곳에서만 필요한 경우라면 클래스 파일로 따로 분리해서 선언하는 것보다 익명 클래스 또는 람다를 사용해서도 구현할 수 있다.</p><p>클라이언트에서 전략 구현체를 직접 구현해서 사용하는 코드를 보자.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service_anonymous_class</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello! Strategy Pattern.&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>(</span><span class=k>new</span> <span class=n>SmsSendingStrategy</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=nd>@Override</span>
</span></span><span class=line><span class=cl>        <span class=kd>public</span> <span class=kt>boolean</span> <span class=nf>execute</span><span class=o>(</span><span class=n>String</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>String</span> <span class=n>smsContents</span><span class=o>)</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;A 외부 서비스 사용: [{}]에게 &#39;{}&#39; 내용 문자 보내기&#34;</span><span class=o>,</span> <span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl>            <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>익명 클래스를 사용하면 위와 같이 구현할 수 있다. 여기에 Java8 이상 버전을 사용하고, 전략 인터페이스가 FuntionalInterface라면, 람다 표현식으로 더욱 깔끔하게 구현할 수도 있다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service_lambda</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello! Strategy Pattern.&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>((</span><span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;A 외부 서비스 사용: [{}]에게 &#39;{}&#39; 내용 문자 보내기&#34;</span><span class=o>,</span> <span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>지금까지는 전략 패턴을 살펴봤다. 템플릿 메서드 패턴에 비해서 상속을 사용하지 않고 인터페이스를 사용하므로, 좀 더 코드를 유연하게 사용할 수 있다. 전략은 더이상 Context(또는 템플릿)에 의존하지 않으므로 자유롭게 필요에 따라 구체적인 전략을 만들고, 또는 새로운 전략 인터페이스를 사용할 수도 있다.</p><h1 id=템플릿-콜백-패턴template-callback-pattern>템플릿 콜백 패턴(Template Callback Pattern)<a hidden class=anchor aria-hidden=true href=#템플릿-콜백-패턴template-callback-pattern>#</a></h1><p>마지막으로, 템플릿 콜백 패턴을 살펴보자. 템플릿 콜백 패턴은 사실 전략 패턴을 몇 가지 방식으로 구현하면서 이미 사용되었다. 전략 패턴의 전략이 콜백으로 변경된 것 뿐이다</p><blockquote><p>프로그래밍에서 <strong>콜백</strong>(callback) 또는 <strong>콜애프터 함수</strong>(call-after function)는 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 말한다. 콜백을 넘겨받는 코드는 이 콜백을 필요에 따라 즉시 실행할 수도 있고, 아니면 나중에 실행할 수도 있다. - <a href=https://ko.wikipedia.org/wiki/%EC%BD%9C%EB%B0%B1>위키백과</a> -</p></blockquote><p>정리하면 콜백 코드는 호출(call)한 곳에서 실행되지 않고, 호출을 요청한 곳(back or callee)에서 실행되는 코드를 말한다.</p><p>이 패턴은 GOF에서 나온 패턴이 아닌, 스프링 프레임워크에서 부르는 패턴이다. 토비의 스프링 책에서 그림을 보면 좀 더 이해하기 쉬울 듯 하다. (토비 스프링 책을 참고하여 예제에 맞게 살짝 수정하였다.)</p><p><img loading=lazy src=https://user-images.githubusercontent.com/34755287/229260331-7db613b2-dae7-4d59-8c08-893e4325a6d4.png alt="Template Callback Pattern"></p><p>위 그림처럼 동작하려면 콜백 코드를 템플릿 메서드에게 넘기는 방법이 필요하다. 자바 8부터는 이러한 코드를 람다 형태로 매개변수로 전달할 수 있다. (자바 8 이전에는 익명 클래스 사용)</p><p>위 그림을 자세히 보면 앞서 전략 패턴을 구현하던 방식 중 람다를 사용한 흐름과 같다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service_lambda</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello! Strategy Pattern.&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>((</span><span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;A 외부 서비스 사용: [{}]에게 &#39;{}&#39; 내용 문자 보내기&#34;</span><span class=o>,</span> <span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>);</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>람다를 사용한 전략패턴을 다시 한 번 보자. 사실 살짝 다른 지점이 보인다. 위는 전략을 필드로 삽입하여, 그림과 매칭하기가 조금 헷갈릴 수가 있다. 전략의 위치를 매개변수로 바꾸고 이를 람다로 하면 완전히 위 그림과 같아질 것이다.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-java data-lang=java><span class=line><span class=cl><span class=nd>@Test</span>
</span></span><span class=line><span class=cl><span class=kt>void</span> <span class=nf>send_sms_using_a_service_lambda</span><span class=o>()</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>cellphoneNumber</span> <span class=o>=</span> <span class=s>&#34;010-1111-2222&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>String</span> <span class=n>smsContents</span> <span class=o>=</span> <span class=s>&#34;Hello! Strategy Pattern.&#34;</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=n>SmsService</span> <span class=n>service</span> <span class=o>=</span> <span class=k>new</span> <span class=n>SmsService</span><span class=o>();</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>service</span><span class=o>.</span><span class=na>sendSms</span><span class=o>(</span><span class=n>cellphoneNumber</span><span class=o>,</span> <span class=n>smsContents</span><span class=o>,</span> <span class=o>(</span><span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>)</span> <span class=o>-&gt;</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=n>log</span><span class=o>.</span><span class=na>info</span><span class=o>(</span><span class=s>&#34;A 외부 서비스 사용: [{}]에게 &#39;{}&#39; 내용 문자 보내기&#34;</span><span class=o>,</span> <span class=n>cellphoneNumber1</span><span class=o>,</span> <span class=n>smsContents1</span><span class=o>);</span>
</span></span><span class=line><span class=cl>        <span class=k>return</span> <span class=kc>true</span><span class=o>;</span>
</span></span><span class=line><span class=cl>    <span class=o>});</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></div><p>위 코드를 보자. <code>sendSms()</code> 메서드의 매개변수로 람다식을 사용했고, 이 코드가 콜백 코드이다. 그림과 매칭해보면, 클라이언트는 테스트 코드 메서드이고, 콜백은 매개변수의 람다식이다. 그리고 템플릿은 <code>sendSms()</code> 메서드이다.</p><p>이를 보면 템플릿 콜백 패턴은 전략 패턴의 용어 중 일부만 살짝 바꾸면 바로 같아진다.</p><ul><li>Strategy Pattern → Template Callback Pattern</li><li>Strategy → Callback</li><li>Context → Template</li></ul><h1 id=정리>정리<a hidden class=anchor aria-hidden=true href=#정리>#</a></h1><p>지금까지 문자 전송 기능 예제를 통해 디자인 패턴 중 템플릿 메서드 패턴, 전략 패턴, 템플릿 콜백 패턴 이렇게 3가지를 살펴보았다. 이 3 가지 디자인 패턴의 의도는 같다. 변경되기 쉬운 코드와 그렇지 않은 코드를 분리하고, 변경되기 쉬운 코드를 추상 메서드 또는 인터페이스로 추상화하여 변경 지점을 추출하였다. 그 결과, 변경을 하더라도 템플릿(또는 컨텍스트) 코드는 그대로이고 이를 어디서든 재사용 및 확장할 수 있게 되었다.</p><p>이는 객체지향 5대 원칙 중에서도 OCP를 만족시키는 대표적인 사례이다. 템플릿(또는 컨텍스트) 코드 기준으로 확장에는 열려있지만, 변경에는 닫혀있다. (사실, 패턴에 더해서 클라이언트라는 제 3자의 위치에서 구체 클래스의 주입까지 더해져서 OCP가 온전히 완성되었음을 인지하고 있어야 한다.)</p><h1 id=참고자료>참고자료<a hidden class=anchor aria-hidden=true href=#참고자료>#</a></h1><ul><li><a href=https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B3%A0%EA%B8%89%ED%8E%B8#>인프런 강의 - [스프링 핵심 원리 - 고급편]</a></li><li><a href=http://www.yes24.com/Product/Goods/17525598>GoF의 디자인 패턴</a></li><li><a href=http://www.yes24.com/Product/Goods/7516721>토비의 스프링 3.1 Vol. 1 스프링의 이해와 원리</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://parker1609.github.io/tags/design-pattern/>Design Pattern</a></li><li><a href=https://parker1609.github.io/tags/template-method-pattern/>Template Method Pattern</a></li><li><a href=https://parker1609.github.io/tags/strategy-pattern/>Strategy Pattern</a></li><li><a href=https://parker1609.github.io/tags/template-callback-pattern/>Template Callback Pattern</a></li><li><a href=https://parker1609.github.io/tags/java/>Java</a></li></ul><nav class=paginav><a class=next href=https://parker1609.github.io/post/java-web-history/><span class=title>Next »</span><br><span>자바 웹 기술 역사</span></a></nav></footer><div id=giscus_thread><script src=https://giscus.app/client.js data-repo=parker1609/parker1609.github.io data-repo-id=R_kgDOI_VMsw data-category=Announcements data-category-id=DIC_kwDOI_VMs84CUTZR data-mapping=og:title data-strict=1 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=ko data-loading=lazy crossorigin=anonymous async></script></div></article></main><footer class=footer><span>&copy; 2023 <a href=https://parker1609.github.io/>Parker Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>